<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<style>
h1 { border-bottom: 4px solid; margin: 0; }
h2 { color: white; background: #880000; border-bottom: 2px solid black; }
h3 { background: #ffccff; border-bottom: 1px solid; }
table { border-collapse: collapse; }
td { padding: 2px; }
.list a { font-weight: bold; }
u { font-weight: bold; }
body { margin: 0; padding: 0; }
.code { border: 1px solid; padding: 0.2em; background: #eeeeee; }
.ctor { background: #ccffcc; }
.event { background: #ffffcc; }
.overridable { background: #cccccc; }
.nav { position: fixed; top: 0; left: 0; width: 20%; }
.main { position: absolute; top: 0; left: 20%; width: 80%; }
.list { margin-top: 1em; }
.list > .head { margin-bottom: 4px; font-weight: bold; background: #88ffff; }
.navhead { font-size: 150%; font-weight: bold; }
.legend { font-size: 80%; margin: 8px 0 8px; }
</style>
<title>Euskit Quick Reference</title>
</head>
<body>

<div class=nav>
<div style="padding: 0.5em;">

<div class=navhead><a href="https://github.com/euske/euskit">Euskit</a></div>

<div class=legend><b>Legend:</b>
<span class=ctor><code>ctor</code></span>,
<span class=event><code>event</code></span>
<span class=overridable><code>overridable</code></span>,
</div>

<div class=list>
<div class=head>Basic Classes:</div>
<a href="#App">App</a>,
<a href="#Scene">Scene</a>,
<a href="#World">World</a>,
<a href="#Task">Task</a>,
<a href="#Entity">Entity</a>,
<a href="#Sprite">Sprite</a>
</div>

<div class=list>
<div class=head>Specialized Classes:</div>
<a href="#Particle">Particle</a>,
<a href="#TileMapEntity">TileMapEntity</a>,
<a href="#PhysicalEntity">PhysicalEntity</a>,
<a href="#GameScene">GameScene</a>
</div>

<div class=list>
<div class=head>Text Library:</div>
<a href="#Font">Font</a>,
<a href="#ShadowFont">ShadowFont</a>,
<a href="#TextBox">TextBox</a>,
<a href="#BannerBox">BannerBox</a>,
<a href="#TextParticle">TextParticle</a>,
<a href="#DialogBox">DialogBox</a>
</div>

<div class=list>
<div class=head>Utility Classes:</div>
<a href="#Signal">Signal</a>,
<a href="#Color">Color</a>,
<a href="#Vec2">Vec2</a>,
<a href="#Vec3">Vec3</a>,
<a href="#Collider">Collider</a>,
<a href="#Shape">Shape</a>,
<a href="#AALine">AALine</a>,
<a href="#Rect">Rect</a>,
<a href="#Circle">Circle</a>,
<a href="#AAPlane">AAPlane</a>,
<a href="#Box">Box</a>,
<a href="#TileMap">TileMap</a>,
<a href="#RangeMap">RangeMap</a>,
<a href="#SpriteSheet">SpriteSheet</a>,
<a href="#PhysicsConfig">PhysicsConfig</a>,
<a href="#TaskList">TaskList</a>,
<a href="#TaskQueue">TaskQueue</a>,
</div>

<div class=list>
<div class=head>Functions:</div>
<a href="#main">Main</a>,
<a href="#misc">Misc.</a>,
<a href="#numeric">Numeric</a>,
<a href="#array">Array</a>,
<a href="#html5">HTML5</a>
</div>

</div>
</div> <!-- nav -->

<div class=main>
<div style="padding: 0.5em;">

<h1>API Quick Reference</h1>

<a name="big-picture"><h2>Big Picture</h2></a>
<div style="position:relative; margin:0; padding:0; height:9em;">
<div style="position:absolute; margin:0; top:0; left:0;">
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="250" height="140">
    <g transform="translate(1.5,1.5)">
      <g fill="none" stroke="black" stroke-width="1">
	<line x1="140" y1="12" x2="55" y2="100" />
	<line x1="140" y1="12" x2="175" y2="100" />
	<ellipse cx="140" cy="12" rx="20" ry="12" fill="white" />
	<rect x="0" y="55" width="110" height="80" fill="white" />
	<rect x="120" y="55" width="110" height="80" fill="white" />
	<rect x="10" y="68" width="80" height="50" fill="white" />
	<rect x="30" y="90" width="16" height="16" />
	<rect x="33" y="93" width="10" height="10" />
	<line x1="45" y1="82" x2="38" y2="98" />
      </g>
      <g style="font-size: 75%;">
	<text x="140" y="15" text-anchor="middle">App</text>
	<text x="165" y="15">Images, ...</text>
	<text x="55" y="52" text-anchor="middle">Scene</text>
	<text x="175" y="52" text-anchor="middle">Scene</text>
	<text x="240" y="100" text-anchor="begin">...</text>
	<text x="45" y="82" text-anchor="begin">Sprite</text>
	<text x="48" y="102" text-anchor="begin">Entity</text>
	<text x="55" y="130" text-anchor="middle">World</text>
      </g>
    </g>
  </svg>
</div>
  <div style="position:absolute; left: 270px; top: 0px; margin:0; line-height: 120%;">
    <a href="#App"><code>App</code></a>:
    Resource management and event loop.<br>
    <a href="#Scene"><code>Scene</code></a>:
    Game state management and event handling.<br>
    <a href="#World"><code>World</code></a>:
    Container where Entities are placed in.<br>
    <a href="#Entity"><code>Entity</code></a>:
    In-game character.<br>
    <a href="#Sprite"><code>Sprite</code></a>:
    Graphical object to be shown.<br>
  </div>
</div>


<a name="basic-classes"><h2>Basic Classes</h2></a>

<a name="App"><h3>App (<code><a href="https://github.com/euske/euskit/blob/master/base/app.ts">app.ts</a></code>)</h3></a>
<p>
Every game has <u>exactly one</u> <code>App</code> object.
It does the basic pluming and resource management (images and sounds); it has
an event loop and connect the game with all the external parts (i.e. a browser).
Typically, you don't have to change this class.
<table border>
<tr class=ctor><td><code>new App(<u>size</u>, <u>framerate</u>, <u>elem</u>)</code></td>
  <td>Creates a new app with given HTML5 resources.</td></tr>
<tr><td><code>.size</code></td>
  <td>Canvas size.</td></tr>
<tr><td><code>.framerate</code></td>
  <td>Frame rate.</td></tr>
<tr><td><code>.elem</code></td>
  <td>HTML element where a canvas is embedded.</td></tr>
<tr><td><code>.canvas</code></td>
  <td>The <code>&lt;canvas&gt;</code> element.</td></tr>
<tr><td><code>.ctx</code></td>
  <td>The <code>CanvasRenderingContext2D</code> object.</td></tr>
<tr><td><code>.audioContext</code></td>
  <td>The <code>AudioContext</code> object.</td></tr>
<tr><td><code>.images</code></td>
  <td>Set of available <code>HTMLImageElement</code> objects.</td></tr>
<tr><td><code>.sounds</code></td>
  <td>Set of available <code>HTMLAudioElement</code> objects.</td></tr>
<tr><td><code>.labels</code></td>
  <td>Set of available <code>HTMLDivElement</code> objects.</td></tr>
<tr><td><code>.scene</code></td>
  <td>Current <code>Scene</code> object that is running.</td></tr>
<tr><td><code>.active</code></td>
  <td><code>true</code> if the game is not suspended.</td></tr>
<tr><td><code>.keys[]</code></td>
  <td>States of the current keys.</td></tr>
<tr><td><code>.keyDir</code></td>
  <td>State of the current 2D input (arrow keys).</td></tr>
<tr><td><code>.mousePos</code></td>
  <td>Current position of the mouse pointer.</td></tr>
<tr><td><code>.mouseButton</code></td>
  <td>Current state of the mouse button.</td></tr>
<tr><td><code>.addElement(<u>bounds</u>)</code></td>
  <td>Adds a new <code>&lt;div&gt;</code> element to the canvas.</td></tr>
<tr><td><code>.removeElement(<u>elem</u>)</code></td>
  <td>Removes the element from the canvas.</td></tr>
<tr><td><code>.lockKeys(<u>t</u>=1)</code></td>
  <td>Blocks the keyboard input to prevent accidental input
    (in a scene transition).</td></tr>
<tr><td><code>.setMusic(<br>&nbsp; <u>name</u>=null, <br>&nbsp; <u>start</u>=0, <u>end</u>=0)</code></td>
  <td>Starts playing the music. When name is <code>null</code>, it stops music.</td></tr>
<tr><td><code>.playSound(<u>name</u>, <u>start</u>=0)</code></td>
  <td>Plays the specified sound.</td></tr>
<tr><td><code>.init(scene)</code></td>
  <td>Initializes the game with the first <code>Scene</code>.</td></tr>
<tr><td><code>.post(msg)</code></td>
  <td>Queues a function that is to be executed at the end of the frame.</td></tr>
</table>

<a name="Scene"><h3>Scene (<code><a href="https://github.com/euske/euskit/blob/master/base/scene.ts">scene.ts</a></code>)</h3></a>
<p>
A <code>Scene</code> is a mini-app or "mode" within the App.
At each moment, exactly one <code>Scene</code> is responsible
for all the user interaction. This is primarily what consists of
a game logic. Euskit supports multiple <code>Scene</code>s,
but it's possible to create an entire game with just one <code>Scene</code>.
<table border>
<tr class=ctor><td><code>new Scene()</code></td>
  <td>Creates a new scene.</td></tr>
<tr class=ctor><td><code>new HTMLScene(<u>text</u>)</code></td>
  <td>Creates a new scene with a static HTML text.</td></tr>
<tr class=ctor><td><code>new GameScene()</code></td>
  <td>Creates a new scene with a <code>World</code> object.</td></tr>
<tr><td><code>.screen</code></td>
  <td>Canvas area <code>Rect</code> object.</td></tr>
<tr><td><code>.reset()</code></td>
  <td>Resets the scene to its initial state.</td></tr>
<tr><td><code>.changeScene(<u>scene</u>)</code></td>
  <td>Signals to switch a scene.</td></tr>
<tr><td><code>.render(<u>ctx</u>)</code></td>
  <td>Displays the scene.</td></tr>
<tr class=overridable><td><code>.onStart()</code></td>
  <td>Invoked when the scene is started.</td></tr>
<tr class=overridable><td><code>.onStop()</code></td>
  <td>Invoked when the scene is finished.</td></tr>
<tr class=overridable><td><code>.onTick()</code></td>
  <td>Invoked for every frame.</td></tr>
<tr class=overridable><td><code>.onDirChanged(<u>v</u>)</code></td>
  <td>Invoked when a directional input is changed.</td></tr>
<tr class=overridable><td><code>.onButtonPressed(<u>keySym</u>)</code></td>
  <td>Invoked when the button state is pressed.</td></tr>
<tr class=overridable><td><code>.onButtonReleased(<u>keySym</u>)</code></td>
  <td>Invoked when the button state is released.</td></tr>
<tr class=overridable><td><code>.onKeyDown(<u>keyCode</u>)</code></td>
  <td>Invoked when a key is pressed.</td></tr>
<tr class=overridable><td><code>.onKeyUp(<u>keyCode</u>)</code></td>
  <td>Invoked when a key is released.</td></tr>
<tr class=overridable><td><code>.onKeyPress(<u>charCode</u>)</code></td>
  <td>Invoked when a character is typed.</td></tr>
<tr class=overridable><td><code>.onMouseDown(<u>p</u>, <u>button</u>)</code></td>
  <td>Invoked when a mouse button is pressed.</td></tr>
<tr class=overridable><td><code>.onMouseUp(<u>p</u>, <u>button</u>)</code></td>
  <td>Invoked when a mouse button is released.</td></tr>
<tr class=overridable><td><code>.onMouseMove(<u>p</u>)</code></td>
  <td>Invoked when a mouse pointer is moved.</td></tr>
<tr class=overridable><td><code>.onFocus()</code></td>
  <td>Invoked when the window is focused.</td></tr>
<tr class=overridable><td><code>.onBlue()</code></td>
  <td>Invoked when the focus is lost.</td></tr>
</table>

<a name="World"><h3>World (<code><a href="https://github.com/euske/euskit/blob/master/base/scene.ts">scene.ts</a></code>)</h3></a>
<p>
A <code>World</code> is a container of <code>Entity</code>s.
The entities which belong here are rendered and their collision is detected.
<table border>
<tr class=ctor><td><code>new World()</code></td>
  <td>Creates a new world.</td></tr>
<tr class=event><td><code>.mouseDown</code></td>
  <td>Fired when a mouse is pressed on an <code>Entity</code>.</td></tr>
<tr class=event><td><code>.mouseUp</code></td>
  <td>Fired when a mouse is released on an <code>Entity</code>.</td></tr>
<tr><td><code>.area</code></td>
  <td>Entire area where entities can move around.</td></tr>
<tr><td><code>.window</code></td>
  <td>Visible part of the world that is rendered.</td></tr>
<tr><td><code>.entities</code></td>
  <td>List of the <code>Entity</code>s that belong to this world.</td></tr>
<tr><td><code>.mouseFocus</code></td>
  <td>The <code>Entity</code> that has the mouse focus (<code>null</code> if none).</td></tr>
<tr><td><code>.mouseActive</code></td>
  <td>The <code>Entity</code> that is currently activated (<code>null</code> if none).</td></tr>
<tr><td><code>.add(<u>entity</u>)</code></td>
  <td>Adds an <code>Entity</code> to this world.</td></tr>
<tr><td><code>.remove(<u>entity</u>)</code></td>
  <td>Removes an <code>Entity</code> from this world.</td></tr>
<tr><td><code>.render(<u>ctx</u>)</code></td>
  <td>Renders every <code>Entity</code>s in the world.</td></tr>
<tr><td><code>.findEntityAt(<u>p</u>)</code></td>
  <td>Returns an Entity that overlaps with point <code>p</code>.</td></tr>
<tr><td><code>.setCenter(<br>&nbsp; <u>target</u>, <br>&nbsp; <u>bounds</u>=null)</code></td>
  <td>Moves the window to cover <code>target</code>, but not exceeding <code>bounds</code>.</td></tr>
<tr><td><code>.moveCenter(<u>v</u>)</code></td>
  <td>Moves the center of the window by <code>v</code>.</td></tr>
<tr><td><code>.moveAll(v)</code></td>
  <td>Moves all the sprites by <code>v</code>.</td></tr>
<tr><td><code>.getEntityColliders(<br>&nbsp; <u>(e:Entity)=&gt;boolean</u>, <br>&nbsp; <u>collider</u>=null)</code></td>
  <td>Returns a list of <code>Entity</code> colliders that overlaps with <code>range</code> (if given).</td></tr>
<tr><td><code>.applyEntities(<br>&nbsp; <u>(e:Entity)=&gt;boolean</u>, <br>&nbsp; <u>collider</u>=null)</code></td>
  <td>Applies the function to each Entity <code>e</code> that overlaps with <code>collider</code> (if given).</td></tr>
<tr class=overridable><td><code>.onMouseDown(<u>p</u>, <u>button</u>)</code></td>
  <td>Invoked when a mouse button is pressed.
<tr class=overridable><td><code>.onMouseUp(<u>p</u>, <u>button</u>)</code></td>
  <td>Invoked when a mouse button is released.
<tr class=overridable><td><code>.onMouseMove(<u>p</u>)</code></td>
  <td>Invoked when a mouse pointer is moved.
</table>

<a name="Task"><h3>Task (<code><a href="https://github.com/euske/euskit/blob/master/base/task.ts">task.ts</a></code>)</h3></a>
<p>
A <code>Task</code> is a base class of <code>Entity</code>.
<table border>
<tr class=ctor><td><code>new Task()</code></td>
  <td>Creates a new empty task.</td></tr>
<tr class=ctor><td><code>new SoundTask(<br>&nbsp; <u>sound</u>, <br>&nbsp; <u>soundStart</u>=MP3_GAP, <br>&nbsp; <u>soundEnd</u>=0)</code></td>
  <td>Task that plays a sound.</td></tr>
<tr class=event><td><code>.stopped</code></td>
  <td>Signal fired when the task stops.</td></tr>
<tr><td><code>.parent</code></td>
  <td><code>TaskList</code> that the task belongs to.</td></tr>
<tr><td><code>.lifetime</code></td>
  <td>Duration that the task can run.</td></tr>
<tr><td><code>.startTime</code></td>
  <td>Time the task started.</td></tr>
<tr><td><code>.getTime()</code></td>
  <td>Elapsed time since the task has started (in seconds).</td></tr>
<tr><td><code>.isScheduled()</code></td>
  <td>True if the task is going to start.</td></tr>
<tr><td><code>.isRunning()</code></td>
  <td>True if the task is in running state.</td></tr>
<tr><td><code>.stop()</code></td>
  <td>Terminates the task.</td></tr>
<tr><td><code>.chain(<u>task</u>, <br>&nbsp; <u>signal</u>=null)</code></td>
  <td>Schedules another task to be started when this task stops.</td></tr>
<tr class=overridable><td><code>.onStart()</code></td>
  <td>Invoked when the task is started.</td></tr>
<tr class=overridable><td><code>.onStop()</code></td>
  <td>Invoked when the task is stopped.</td></tr>
<tr class=overridable><td><code>.onTick()</code></td>
  <td>Invoked at every frame while the task is running.</td></tr>
</table>

<a name="Entity"><h3>Entity : <a href="#Task">Task</a> (<code><a href="https://github.com/euske/euskit/blob/master/base/entity.ts">entity.ts</a></code>)</h3></a>
<p>
An <code>Entity</code> is a main object for game characters.
Each Entity is a <code>Task</code> and has a <code>Collider</code> and one or more
Sprites.
<table border>
<tr class=ctor><td><code>new Entity(<u>pos</u>)</code></td>
  <td>Creates a new entity at a given position.</td></tr>
<tr><td><code>.pos</code></td>
  <td>Entity position.</td></tr>
<tr><td><code>.collider</code></td>
  <td><code>Rect</code>/<code>Circle</code> for the entity's collider.</td></tr>
<tr><td><code>.sprites</code></td>
  <td><code>Sprite</code>s that belongs to this entity.</td></tr>
<tr><td><code>.order</code></td>
  <td>Order of the entity being rendered.</td></tr>
<tr><td><code>.rotation</code></td>
  <td>Rotation of the sprite (in radian).</td></tr>
<tr><td><code>.scale</code></td>
  <td>Vector for the scale of the sprite.</td></tr>
<tr><td><code>.alpha</code></td>
  <td>Alpha value of the sprite.</td></tr>
<tr class=overridable><td><code>.isVisible()</code></td>
  <td>Returns <code>true</code> if the entity sprite is visible.</td></tr>
<tr><td><code>.render(<u>ctx</u>)</code></td>
  <td>Render the entity.</td></tr>
<tr><td><code>.getCollider(<u>pos</u>=null)</code></td>
  <td>Returns the collider for the given <code>pos</code>.</td></tr>
<tr><td><code>.canMove(<u>v</u>, <br>&nbsp; <u>context</u>=null)</code></td>
  <td><code>true</code> if the entity is movable toward <code>v</code>.</td></tr>
<tr><td><code>.getMove(<u>pos</u>, <u>v</u>, <br>&nbsp; <u>context</u>=null)</code></td>
  <td>Trims the vector <code>v</code> so that it doesn't collide.</td></tr>
<tr><td><code>.movePos(<u>v</u>)</code></td>
  <td>Moves the entity by <code>v</code>.</td></tr>
<tr><td><code>.moveIfPossible(<u>v</u>, <br>&nbsp; <u>context</u>=null)</code></td>
  <td>Moves the entity by <code>v</code> without colliding obstacles.</td></tr>
<tr><td><code>.getObstaclesFor(<br>&nbsp; <u>range</u>, <u>v</u>, <u>context</u>)</code></td>
  <td>Returns a list of <code>Shape</code>s within <code>range</code>.</td></tr>
<tr><td><code>.getFencesFor(<br>&nbsp; <u>range</u>, <u>v</u>, <u>context</u>)</code></td>
  <td>Returns a list of bounding rectangles that limits the entity within.</td></tr>
<tr class=overridable><td><code>.onCollided(<u>entity</u>)</code></td>
  <td>Invoked when the entity collides another entity.</td></tr>
</table>

<a name="Sprite"><h3>Sprite (<code><a href="https://github.com/euske/euskit/blob/master/base/sprite.ts">sprite.ts</a></code>)</h3></a>
<p>
A <code>Sprite</code> is something to be displayed.
<table border>
<tr class=ctor><td><code>new RectSprite(<u>color</u>, <u>dstRect</u>)</code></td>
  <td>Sprite with a filled rectangle.</td></tr>
<tr class=ctor><td><code>new OvalSprite(<u>color</u>, <u>dstRect</u>)</code></td>
  <td>Sprite with a filled oval.</td></tr>
<tr class=ctor><td><code>new CanvasSprite(<br>&nbsp; <u>canvas</u>, <br>&nbsp; <u>srcRect</u>=null, <u>dstRect</u>=null)</code></td>
  <td>Sprite that refers to a portion of
    <code>&lt;canvas&gt;</code> element.</td></tr>
<tr class=ctor><td><code>new HTMLSprite(<br>&nbsp; <u>image</u>, <br>&nbsp; <u>srcRect</u>=null, <u>dstRect</u>=null)</code></td>
  <td>Sprite that refers to a portion of
    <code>&lt;img&gt;</code> element.</td></tr>
<tr class=ctor><td><code>new TiledSprite(<br>&nbsp; <u>sprite</u>, <u>bounds</u>, <br>&nbsp; <u>offset</u>=null)</code></td>
  <td>Sprite that is composed of another Sprite.</td></tr>
<tr class=ctor><td><code>new StarSprite(<br>&nbsp; <u>bounds</u>, <u>nstars</u>, <br>&nbsp; <u>maxdepth</u>=3, <u>sprites</u>=null)</code></td>
  <td>Sprite that can be used for "star flowing" effects.</td></tr>
<tr><td><code>.getBounds()</code></td>
  <td>Returns the bounds rectangle of the Sprite.</td></tr>
<tr><td><code>.render(<u>ctx</u>)</code></td>
  <td>Renders the image at (0, 0) in the given Context.</td></tr>
</table>

<a name="specialized-objects"><h2>Specialized Objects</h2></a>

<a name="Particle"><h3>Particle : <a href="#Entity">Entity</a> (<code><a href="https://github.com/euske/euskit/blob/master/base/entity.ts">entity.ts</a></code>)</h3></a>
<p>
A <code>Particle</code> is an <code>Entity</code> that
keeps moving towards a specific direction.
<table border>
<tr class=ctor><td><code>new Particle(<u>pos</u>)</code></td>
  <td>Creates a new particle that keeps moving.</td></tr>
<tr><td><code>.movement</code></td>
  <td>Velocity of the object.</td></tr>
<tr><td><code>.getFrame()</code></td>
  <td>Returns the <code>Rect</code> where the entity is kept alive within.</td></tr>
</table>

<a name="TileMapEntity"><h3>TileMapEntity : <a href="#Entity">Entity</a> (<code><a href="https://github.com/euske/euskit/blob/master/base/entity.ts">entity.ts</a></code>)</h3></a>
<p>
A <code>TileMapEntity</code> is an <code>Entity</code> that
interacts with a <code>TileMap</code>.
<table border>
<tr class=ctor><td><code>new TileMapEntity(<br>&nbsp; <u>tilemap</u>, <br>&nbsp; <u>(e:Entity)=&gt;boolean</u>)</code></td>
  <td>Creates a new entity that interacts with a tilemap.</td></tr>
<tr><td><code>.tilemap</code></td>
  <td>TileMap to be interacted with.</td></tr>
<tr><td><code>.isObstacle</code></td>
  <td>Function that identifies an obstacle.</td></tr>
</table>

<a name="PhysicalEntity"><h3>PhysicalEntity : <a href="#Entity">Entity</a> (<code><a href="https://github.com/euske/euskit/blob/master/base/entity.ts">entity.ts</a></code>)</h3></a>
<p>
An <code>Entity</code> that is affected by gravity.
<table border>
<tr class=ctor><td><code>new PhysicalEntity(<br>&nbsp; <u>physics</u>, <u>pos</u>)</code></td>
  <td>Creates a new entity that is affected by gravity.</td></tr>
<tr class=ctor><td><code>new PlatformerEntity(<br>&nbsp; <u>tilemap</u>, <u>physics</u>, <u>pos</u>)</code></td>
  <td>Creates a new <code>PhysicalEntity</code> + <code>TileMapEntity</code>.</td></tr>
<tr><td><code>.setJump(<u>jumpend</u>)</code></td>
  <td>Starts a jump maneuver that ends at <code>t=jumpend</code>.</td></tr>
<tr><td><code>.fall()</code></td>
  <td>Invoked for every update.</td></tr>
<tr><td><code>.isJumping()</code></td>
  <td><code>true</code> if the entity is jumping.</td></tr>
<tr><td><code>.isLanded()</code></td>
  <td><code>true</code> if the entity is landed on a platform.</td></tr>
<tr class=overridable><td><code>.canJump()</code></td>
  <td><code>true</code> if the entity can jump.</td></tr>
<tr class=overridable><td><code>.canFall()</code></td>
  <td><code>true</code> if the entity can fall.</td></tr>
<tr class=overridable><td><code>.onJumped()</code></td>
  <td>Invoked when the entity starts jumping.</td></tr>
<tr class=overridable><td><code>.onLanded()</code></td>
  <td>Invoked when the entity is landed.</td></tr>
</table>

<a name="GameScene"><h3>GameScene : <a href="#Scene">Scene</a> (<code><a href="https://github.com/euske/euskit/blob/master/base/scene.ts">scene.ts</a></code>)</h3></a>
<p>
A <code>Scene</code> that has a <code>World</code> and convenient methods.
<table border>
<tr class=ctor><td><code>new GameScene()</code></td>
  <td>Creates a new scene.</td></tr>
<tr><td><code>.add(<u>entity</u>)</code></td>
  <td>Adds an <code>Entity</code> to the world.</td></tr>
<tr><td><code>.remove(<u>entity</u>)</code></td>
  <td>Removes an <code>Entity</code> from the world.</td></tr>
</table>

<a name="text"><h2>Text Library</h2></a>

<a name="Font"><h3>Font (<code>text.ts</code>)</h3></a>
<p>
A <code>Font</code> represents a monospace bitmap font.
<table border>
<tr class=ctor><td><code>new Font(<br>&nbsp; <u>glyphs</u>, <br>&nbsp; <u>color</u>=null, <u>scale</u>=1)</code></td>
  <td>Font with a given <code>glyphs</code>.</td></tr>
<tr class=ctor><td><code>new InvertedFont(<br>&nbsp; <u>glyphs</u>, <br>&nbsp; <u>color</u>=null, <u>scale</u>=1)</code></td>
  <td>Inverted Font.</td></tr>
<tr class=ctor><td><code>new ShadowFont(<br>&nbsp; <u>glyphs</u>, <br>&nbsp; <u>color</u>=null, <u>scale</u>=1,<br>&nbsp; <u>shadowColor</u>='black',<br>&nbsp; <u>shadowDist</u>=1</em>)</code></td>
  <td>Font with shadow.</td></tr>
<tr><td><code>.width</code></td>
  <td>Width of each character.</td></tr>
<tr><td><code>.height</code></td>
  <td>Height of each character.</td></tr>
<tr><td><code>.background</code></td>
  <td>Background color (<code>null</code> for transparent).</td></tr>
<tr><td><code>.getSize(<u>text</u>)</code></td>
  <td>Computes the pixel size for a given text.</td></tr>
<tr><td><code>.renderString(<br>&nbsp; <u>ctx</u>, <u>text</u>, <u>x</u>, <u>y</u>)</code></td>
  <td>Draws the text at a given location.</td></tr>
</table>

<a name="TextBox"><h3>TextBox : <a href="#Sprite">Sprite</a> (<code>text.ts</code>)</h3></a>
<p>
A type of <code>Sprite</code> for a monospaced text.
<table border>
<tr class=ctor><td><code>new TextBox(<br>&nbsp; <u>frame</u>, <u>font</u>=null)</code></td>
  <td>TextBox with a given frame and font.</td></tr>
<tr><td><code>.frame</code></td>
  <td>Area of text displayed.</td></tr>
<tr><td><code>.font</code></td>
  <td>Default font.</td></tr>
<tr><td><code>.header</code></td>
  <td>Header string for each line.</td></tr>
<tr><td><code>.lineSpace</code></td>
  <td>Space between lines.</td></tr>
<tr><td><code>.padding</code></td>
  <td>Padding between text and frame.</td></tr>
<tr><td><code>.background</code></td>
  <td>Background color (<code>null</code> for transparency).</td></tr>
<tr><td><code>.borderColor</code></td>
  <td>Border color (<code>null</code> for no border).</td></tr>
<tr><td><code>.borderWidth</code></td>
  <td>Border width.</td></tr>
<tr><td><code>.getBounds()</code></td>
  <td>Returns the frame rectangle.</td></tr>
<tr><td><code>.getInnerBounds()</code></td>
  <td>Returns the area that the actual text is displayed.</td></tr>
<tr><td><code>.clear()</code></td>
  <td>Clears all the texts displayed.</td></tr>
<tr><td><code>.addSegment(<u>pt</u>, <br>&nbsp; <u>text</u>, <u>font</u>=null)</code></td>
  <td>Add a text segment at a given location.</td></tr>
<tr><td><code>.addText(<br>&nbsp; <u>text</u>, <u>font</u>=null)</code></td>
  <td>Append a text.</td></tr>
<tr><td><code>.addNewline(<u>font</u>=null)</code></td>
  <td>Append a newline.</td></tr>
<tr><td><code>.putText(<u>lines</u>, <br>&nbsp; <u>halign</u>='left', <u>valign</u>='top')</code></td>
  <td>Layout the given lines.</td></tr>
<tr><td><code>.getSize(<u>lines</u>, <br>&nbsp; <u>font</u>=null)</code></td>
  <td>Computes the pixel size for a given text.</td></tr>
<tr><td><code>.wrapLines(<u>text</u>, <br>&nbsp; <u>font</u>=null, <u>header</u>=null)</code></td>
  <td>Split the text into lines that can fit the textbox.</td></tr>
<tr><td><code>.render(ctx)</code></td>
  <td>Draws the text.</td></tr>
</table>

<a name="DialogBox"><h3>DialogBox : <a href="#Entity">Entity</a> (<code>text.ts</code>)</h3></a>
<p>
This is a rather complex class for showing text dialog or menu.
<table border>
<tr class=ctor><td><code>new DialogBox(<br>&nbsp; <u>textbox</u>, <u>hiFont</u>=null)</code></td>
  <td>Create a new DialogBox with a given highlight font.</td></tr>
<tr><td><code>.addPause(<u>duration</u>)</code></td>
  <td>Schedule a pause during a dialog.</td></tr>
<tr><td><code>.addDisplay(<br>&nbsp; <u>text</u>, <u>speed</u>=-1, <br>&nbsp; <u>sound</u>=null, <br>&nbsp; <u>font</u>=null)</code></td>
  <td>Schedule displaying text with a given speed, font and sound effect.</td></tr>
<tr><td><code>.addMenu()</code></td>
  <td>Schedule displaying a menu.</td></tr>
<tr><td><code>.addWait()</code></td>
  <td>Schedule waiting.</td></tr>
<tr><td><code>.ff()</code></td>
  <td>Fast-forward and show all the texts.</td></tr>
<tr><td><code>.clear()</code></td>
  <td>Clears all the texts and tasks.</td></tr>
</table>

<a name="BannerBox"><h3>BannerBox : <a href="#Entity">Entity</a> (<code>text.ts</code>)</h3></a>
<p>
An <code>Entity</code> for showing text banners.
<table border>
<tr class=ctor><td><code>new BannerBox(<br>&nbsp; <u>frame</u>, <u>font</u>, <br>&nbsp; <u>lines</u>=null, <br>&nbsp; <u>lineSpace</u>=4)</code></td>
  <td>TextBox with a given frame and font.</td></tr>
<tr><td><code>.interval</code></td>
  <td>Blinking interval (0: no blinking).</td></tr>
<tr><td><code>.putText(<u>lines</u>, <br>&nbsp; <u>halign</u>='center', <br>&nbsp; <u>valign</u>='center')</code></td>
  <td>Layout the given lines.</td></tr>
</table>

<a name="TextParticle"><h3>TextParticle : <a href="#BannerBox">BannerBox</a> (<code>text.ts</code>)</h3></a>
<p>
A short-lived text particle.
<table border>
<tr class=ctor><td><code>new TextParticle(<br>&nbsp; <u>pos</u>, <u>font</u>, <u>text</u>, <br>&nbsp; <u>borderWidth</u>=1)</code></td>
  <td>Creates a new text particle.</td></tr>
<tr><td><code>.movement</code></td>
  <td>Velocity of the object.</td></tr>
</table>

<a name="animation"><h2>Animation Library</h2></a>

<p>
TODO

<a name="Animator"><h3>Animator : <a href="#Task">Task</a> (<code><a href="https://github.com/euske/euskit/blob/master/base/animation.ts">animation.ts</a></code>)</h3></a>

<a name="Blinker"><h3>Blinker : <a href="#Entity">Entity</a> (<code><a href="https://github.com/euske/euskit/blob/master/base/animation.ts">animation.ts</a></code>)</h3></a>

<a name="Tweener"><h3>Tweener : <a href="#Animator">Animator</a> (<code><a href="https://github.com/euske/euskit/blob/master/base/animation.ts">animation.ts</a></code>)</h3></a>
<a name="PolyTweener"><h3>PolyTweener : <a href="#Tweener">Tweener</a> (<code><a href="https://github.com/euske/euskit/blob/master/base/animation.ts">animation.ts</a></code>)</h3></a>
<a name="PolyTweenerIn"><h3>PolyTweenerIn : <a href="#PolyTweener">PolyTweener</a> (<code><a href="https://github.com/euske/euskit/blob/master/base/animation.ts">animation.ts</a></code>)</h3></a>
<a name="PolyTweenerOut"><h3>PolyTweenerOut : <a href="#PolyTweener">PolyTweener</a> (<code><a href="https://github.com/euske/euskit/blob/master/base/animation.ts">animation.ts</a></code>)</h3></a>
<a name="PolyTweenerInOut"><h3>PolyTweenerInOut : <a href="#PolyTweener">PolyTweener</a> (<code><a href="https://github.com/euske/euskit/blob/master/base/animation.ts">animation.ts</a></code>)</h3></a>

<a name="pathfinding"><h2>Pathfinding Library</h2></a>

<p>
TODO

<a name="PlanActor"><h3>PlanActor (<code><a href="https://github.com/euske/euskit/blob/master/base/pathfind.ts">pathfind.ts</a></code>)</h3></a>
<a name="PlanAction"><h3>PlanAction (<code><a href="https://github.com/euske/euskit/blob/master/base/pathfind.ts">pathfind.ts</a></code>)</h3></a>
<a name="PlanProfile"><h3>PlanProfile (<code><a href="https://github.com/euske/euskit/blob/master/base/pathfind.ts">pathfind.ts</a></code>)</h3></a>
<a name="PlanMap"><h3>PlanMap (<code><a href="https://github.com/euske/euskit/blob/master/base/pathfind.ts">pathfind.ts</a></code>)</h3></a>
<a name="PlanActionRunner"><h3>PlanActionRunner (<code><a href="https://github.com/euske/euskit/blob/master/base/pathfind.ts">pathfind.ts</a></code>)</h3></a>
<a name="PlanningEntity"><h3>PlanningEntity (<code><a href="https://github.com/euske/euskit/blob/master/base/pathfind.ts">pathfind.ts</a></code>)</h3></a>

<a name="utility-classes"><h2>Utility Classes</h2></a>

<a name="Signal"><h3>Signal (<code><a href="https://github.com/euske/euskit/blob/master/base/utils.ts">utils.ts</a></code>)</h3></a>
<p>
A <code>Signal</code> represents an event that is attached to a
certain object and other objects can get notified.
<table border>
<tr class=ctor><td><code>new Signal(<em>baseargs</em>, ...)</code></td>
  <td>New <code>Signal</code> object with given <code>baseargs</code>.</td></tr>
<tr><td><code>.receivers</code></td>
  <td>List of the receiver functions.</td></tr>
<tr><td><code>.subscribe(<u>receiver</u>)</code></td>
  <td>Adds <code>receiver</code> to the subscriber list.</td></tr>
<tr><td><code>.unsubscribe(<u>receiver</u>)</code></td>
  <td>Removes <code>receiver</code> from the subscriber list.</td></tr>
<tr><td><code>.fire(<em>extraargs</em>, ...)</code></td>
  <td>Sends a message to all the subscribers.
    Each receiver function gets (<code>baseargs</code> + <code>extraargs</code>)
    for arguments.</td></tr>
</table>

<a name="Color"><h3>Color (<code><a href="https://github.com/euske/euskit/blob/master/base/utils.ts">utils.ts</a></code>)</h3></a>
<p>
A <code>Color</code> represents an RGBA value.
<table border>
<tr class=ctor><td><code>new Color(<u>r</u>, <u>g</u>, <u>b</u>, <u>a</u>=1.0)</code></td>
  <td>New <code>Color</code> object for RGBA values.</td></tr>
<tr><td><code>.r</code></td>
  <td>Red value.</td></tr>
<tr><td><code>.g</code></td>
  <td>Green value.</td></tr>
<tr><td><code>.b</code></td>
  <td>Blue value.</td></tr>
<tr><td><code>.a</code></td>
  <td>Alpha value.</td></tr>
<tr><td><code>.setAlpha(<u>a</u>)</code></td>
  <td>Creates a <code>Color</code> with a given alpha.</td></tr>
<tr><td><code>.multiply(<u>t</u>)</code></td>
  <td>Multiplies each component by <code>t</code>.</tr>
<tr><td><code>.blend(<u>color</u>, <u>t</u>)</code></td>
  <td>Blends with another <code>Color</code> with ratio <code>t</code>.</tr>
<tr><td><code>Color.generate(<u>h</u>, <u>v</u>=1.0)</code></td>
  <td>Creates a <code>Color</code> with a given hue.</td></tr>
</table>

<a name="Vec2"><h3>Vec2 (<code><a href="https://github.com/euske/euskit/blob/master/base/geom.ts">geom.ts</a></code>)</h3></a>
<p>
A <code>Vec2</code> represents two-dimensional vector that has (x, y) elements.
<table border>
<tr class=ctor><td><code>new Vec2(<u>x</u>=0, <u>y</u>=0)</code></td>
  <td>New 2D vector (<code>x</code>, <code>y</code>).</td></tr>
<tr><td><code>.x</code></td>
  <td>X value.</td></tr>
<tr><td><code>.y</code></td>
  <td>Y value.</td></tr>
<tr><td><code>.copy()</code></td>
  <td>Duplicates the vector.</td></tr>
<tr><td><code>.equals(<u>p</u>)</code></td>
  <td><code>true</code> if the vector is identical to <code>p</code>.</td></tr>
<tr><td><code>.isZero()</code></td>
  <td><code>true</code> if the vector is zero length.</td></tr>
<tr><td><code>.len2()</code></td>
  <td>Length<sup>2</sup> of the vector.</td></tr>
<tr><td><code>.len()</code></td>
  <td>Length of the vector.</td></tr>
<tr><td><code>.sign()</code></td>
  <td>(<code>sign(x)</code>, <code>sign(y)</code>).</td></tr>
<tr><td><code>.add(<u>v</u>)</code></td>
  <td>(<code>this</code> + <code>v</code>).</td></tr>
<tr><td><code>.sub(<u>v</u>)</code></td>
  <td>(<code>this</code> - <code>v</code>).</td></tr>
<tr><td><code>.scale(<u>n</u>)</code></td>
  <td>(<code>n</code> &sdot; <code>this</code>).</td></tr>
<tr><td><code>.distance(<u>p</u>)</code></td>
  <td>|<code>this</code> - <code>p</code>|.</td></tr>
<tr><td><code>.clamp(<u>bounds</u>)</code></td>
  <td>(<code>clamp(x)</code>, <code>clamp(y)</code>).</td></tr>
<tr><td><code>.move(<u>dx</u>, <u>dy</u>)</code></td>
  <td>(<code>x+dx</code>, <code>y+dy</code>).</td></tr>
<tr><td><code>.interpolate(<u>p</u>, <u>t</u>)</code></td>
  <td>(<code>this*(1-t) + p*t)</code>.</td></tr>
<tr><td><code>.rotate(<u>d</u>)</code></td>
  <td>Creates a rotated vector in radian (clockwise...0&lt;<code>d</code>)</td></tr>
<tr><td><code>.rot90(<u>d</u>)</code></td>
  <td>Creates a rotated vector by 90 degrees (clockwise...0&lt;<code>d</code>)</td></tr>
<tr><td><code>.expand(<br>&nbsp; <u>dw</u>, <u>dh</u>, <u>anchor</u>='c')</code></td>
  <td>Creates a <code>Rect</code> with the point as an anchor.</td></tr>
</table>

<a name="Vec3"><h3>Vec3 (<code><a href="https://github.com/euske/euskit/blob/master/base/geom.ts">geom.ts</a></code>)</h3></a>
<p>
A <code>Vec3</code> represents three-dimensional vector that has (x, y, z) elements.
<table border>
<tr class=ctor><td><code>new Vec3(<u>x</u>=0, <u>y</u>=0, <u>z</u>=0)</code></td>
  <td>New 3D vector (<code>x</code>, <code>y</code>, <code>z</code>).</td></tr>
<tr><td><code>.x</code></td>
  <td>X value.</td></tr>
<tr><td><code>.y</code></td>
  <td>Y value.</td></tr>
<tr><td><code>.z</code></td>
  <td>Z value.</td></tr>
<tr><td><code>.copy()</code></td>
  <td>Duplicates the vector.</td></tr>
<tr><td><code>.equals(<u>p</u>)</code></td>
  <td><code>true</code> if <code>p</code> is identical.</td></tr>
<tr><td><code>.isZero()</code></td>
  <td><code>true</code> if the vector is zero length.</td></tr>
<tr><td><code>.len2()</code></td>
  <td>Length<sup>2</sup> of the vector.</td></tr>
<tr><td><code>.len()</code></td>
  <td>Length of the vector.</td></tr>
<tr><td><code>.sign()</code></td>
  <td>(<code>sign(x)</code>, <code>sign(y)</code>, <code>sign(z)</code>).</td></tr>
<tr><td><code>.add(<u>v</u>)</code></td>
  <td>(<code>this</code> + <code>v</code>).</td></tr>
<tr><td><code>.sub(<u>v</u>)</code></td>
  <td>(<code>this</code> - <code>v</code>).</td></tr>
<tr><td><code>.scale(<u>n</u>)</code></td>
  <td>(<code>n</code> &sdot; <code>this</code>).</td></tr>
<tr><td><code>.distance(<u>p</u>)</code></td>
  <td>|<code>this</code> - <code>p</code>|.</td></tr>
<tr><td><code>.clamp(<u>bounds</u>)</code></td>
  <td>(<code>clamp(x)</code>, <code>clamp(y)</code>, <code>clamp(z)</code>).</td></tr>
<tr><td><code>.move(<u>dx</u>, <u>dy</u>, <u>dz</u>)</code></td>
  <td>(<code>x+dx</code>, <code>y+dy</code>, <code>z+dz</code>).</td></tr>
<tr><td><code>.interpolate(<u>p</u>, <u>t</u>)</code></td>
  <td>(<code>this*(1-t) + p*t)</code>.</td></tr>
</table>

<a name="Collider"><h3>Collider (<code><a href="https://github.com/euske/euskit/blob/master/base/geom.ts">geom.ts</a></code>)</h3></a>
<p>
A <code>Collider</code> is an abstract geometric object
that can be used for hit detection.
<table border>
<tr><td><code>.copy()</code></td>
  <td>Duplicates the collider.</td></tr>
<tr><td><code>.move(<u>dx</u>, <u>dy</u>)</code></td>
  <td>Creates a collider moved by (<code>dx</code>, <code>dy</code>).</td></tr>
<tr><td><code>.add(<u>v</u>)</code></td>
  <td>Creates a collider moved by <code>v</code>.</td></tr>
<tr><td><code>.sub(<u>v</u>)</code></td>
  <td>Creates a collider moved by <code>-v</code>.</td></tr>
<tr><td><code>.equals(<u>collider</u>)</code></td>
  <td><code>true</code> if <code>collider</code> is identical.</td></tr>
<tr><td><code>.overlaps(<u>collider</u>)</code></td>
  <td><code>true</code> if this collider overlaps <code>collider</code>.</td></tr>
<tr><td><code>.contact(<u>v</u>, <u>collider</u>)</code></td>
  <td>Trims a vector so that <code>collider</code> doesn't collide with this.</td></tr>
<tr><td><code>.getAABB()</code></td>
  <td>Returns the AABB of the collider.</td></tr>
</table>

<a name="Shape"><h3>Shape : <a href="#Collider">Collider</a> (<code><a href="https://github.com/euske/euskit/blob/master/base/geom.ts">geom.ts</a></code>)</h3></a>
<p>
A <code>Shape</code> is an abstract object that has a clear boundary and
represents an enclosed shape.
<table border>
<tr><td><code>.isZero()</code></td>
  <td><code>true</code> if the shape is empty.</td></tr>
<tr><td><code>.containsPt(<u>p</u>)</code></td>
  <td><code>true</code> if the shape contains <code>p</code>.</td></tr>
<tr><td><code>.edgePt(<u>t</u>)</code></td>
  <td>Returns a point on the contour.</td></tr>
<tr><td><code>.rndPt()</code></td>
  <td>Returns a random point within the shape.</td></tr>
<tr><td><code>.rndPtEdge()</code></td>
  <td>Returns a random point on the edge.</td></tr>
</table>

<a name="AALine"><h3>AALine : <a href="#Collider">Collider</a> (<code><a href="https://github.com/euske/euskit/blob/master/base/geom.ts">geom.ts</a></code>)</h3></a>
<p>
A <code>AALine</code> represents an axis-aligned (either horizontal or
parpendicular) line.
<table border>
<tr class=ctor><td><code>new AALine(<u>x0</u>, <u>y0</u>, <u>x1</u>, <u>y1</u>)</code></td>
  <td>New AALine.</td></tr>
<tr><td><code>.x0</code></td>
  <td>Left x value.</td></tr>
<tr><td><code>.y0</code></td>
  <td>Top y value.</td></tr>
<tr><td><code>.x1</code></td>
  <td>Right x value.</td></tr>
<tr><td><code>.y1</code></td>
  <td>Bottom y value.</td></tr>
</table>

<a name="Rect"><h3>Rect : <a href="#Shape">Shape</a> (<code><a href="https://github.com/euske/euskit/blob/master/base/geom.ts">geom.ts</a></code>)</h3></a>
<p>
A <code>Rect</code> object is a 2D rectangle that
has its position (x, y) and size (width, height).
<table border>
<tr class=ctor><td><code>new Rect(<br>&nbsp; <u>x</u>=0, <u>y</u>=0,<br>&nbsp; <u>width</u>=0, <u>height</u>=0)</code></td>
  <td>New rectangle (<code>x</code>, <code>y</code>, <code>width</code>, <code>height</code>).</td></tr>
<tr><td><code>.x</code></td>
  <td>X value of the top-left corner.</td></tr>
<tr><td><code>.y</code></td>
  <td>Y value of the top-left corner.</td></tr>
<tr><td><code>.width</code></td>
  <td>Width of the rectangle.</td></tr>
<tr><td><code>.height</code></td>
  <td>Height of the rectangle.</td></tr>
<tr><td><code>.x1()</code></td>
  <td>X value of the right edge of the rectangle.</td></tr>
<tr><td><code>.y1()</code></td>
  <td>Y value of the bottom edge of the rectangle.</td></tr>
<tr><td><code>.cx()</code></td>
  <td>Center x of the rectangle.</td></tr>
<tr><td><code>.cy()</code></td>
  <td>Center y of the rectangle.</td></tr>
<tr><td><code>.center()</code></td>
  <td>Center point of the rectangle.</td></tr>
<tr><td><code>.topLeft()</code></td>
  <td>Top left corner of the rectangle.</td></tr>
<tr><td><code>.topRight()</code></td>
  <td>Top right corner of the rectangle.</td></tr>
<tr><td><code>.bottomLeft()</code></td>
  <td>Bottom left corner of the rectangle.</td></tr>
<tr><td><code>.bottomRight()</code></td>
  <td>Bottom right corner of the rectangle.</td></tr>
<tr><td><code>.anchor(<u>anchor</u>)</code></td>
  <td>Anchor point of the rectangle:
    <div style="margin-left:1em;">
      <svg xmlns="http://www.w3.org/2000/svg"
	   xmlns:xlink="http://www.w3.org/1999/xlink"
	   version="1.1" width="125" height="49">
	<g transform="translate(2.5,2.5)">
	  <g fill="none" stroke="black" stroke-width="1">
	    <rect x="0" y="0" width="120" height="44" />
	    <circle cx="0" cy="0" r="2" />
	    <circle cx="60" cy="0" r="2" />
	    <circle cx="120" cy="0" r="2" />
	    <circle cx="0" cy="22" r="2" />
	    <circle cx="60" cy="22" r="2" />
	    <circle cx="120" cy="22" r="2" />
	    <circle cx="0" cy="44" r="2" />
	    <circle cx="60" cy="44" r="2" />
	    <circle cx="120" cy="44" r="2" />
	  </g>
	  <g style="font-family: monospace;">
	    <text x="0" y="11" text-anchor="begin">nw</text>
	    <text x="60" y="11" text-anchor="middle">n</text>
	    <text x="120" y="11" text-anchor="end">ne</text>
	    <text x="0" y="26" text-anchor="begin">w</text>
	    <text x="120" y="26" text-anchor="end">e</text>
	    <text x="0" y="41" text-anchor="begin">sw</text>
	    <text x="60" y="41" text-anchor="middle">s</text>
	    <text x="120" y="41" text-anchor="end">se</text>
	  </g>
	</g>
      </svg>
    </div>
  </td></tr>
<tr><td><code>.edge(<u>direction</u>)</code></td>
  <td>Returns an edge of the rectangle.
    <div style="margin-left:1em;">
      <svg xmlns="http://www.w3.org/2000/svg"
	   xmlns:xlink="http://www.w3.org/1999/xlink"
	   version="1.1" width="125" height="49">
	<g transform="translate(2.5,2.5)">
	  <g fill="none" stroke="black" stroke-width="1">
	    <rect x="0" y="0" width="80" height="40" />
	    <g stroke-width="3">
	    <line x1="30" x2="50" y1="0" y2="0" />
	    <line x1="0" x2="0" y1="10" y2="30" />
	    <line x1="80" x2="80" y1="10" y2="30" />
	    <line x1="30" x2="50" y1="40" y2="40" />
	    </g>
	  </g>
	  <g style="font-family: monospace;">
	    <text x="40" y="11" text-anchor="middle">n</text>
	    <text x="2" y="25" text-anchor="begin">w</text>
	    <text x="78" y="25" text-anchor="end">e</text>
	    <text x="40" y="37" text-anchor="middle">s</text>
	  </g>
	</g>
      </svg>
    </div>
  </td></tr>
<tr><td><code>.inflate(<u>dw</u>, <u>dh</u>)</code></td>
  <td>Creates a inflated/deflated rectangle by (<code>dw&times;2</code>, <code>dh&times;2</code>):
    <div style="margin-left:1em;">
      <svg xmlns="http://www.w3.org/2000/svg"
	   xmlns:xlink="http://www.w3.org/1999/xlink"
	   version="1.1" width="100" height="48">
	<g transform="translate(1.5,1.5)">
	  <g fill="none" stroke="black" stroke-width="1">
	    <rect x="20" y="12" width="50" height="20" />
	    <rect x="0" y="0" width="90" height="44" />
	    <line x1="0" y1="22" x2="20" y2="22" />
	    <line x1="45" y1="0" x2="45" y2="12" />
	    <line x1="45" y1="32" x2="45" y2="44" />
	    <line x1="70" y1="22" x2="90" y2="22" />
	    <circle cx="45" cy="22" r="2" />
	  </g>
	  <g style="font-size: 75%;">
	    <text x="1" y="20">dw</text>
	    <text x="46" y="11">dh</text>
	    <text x="46" y="43">dh</text>
	    <text x="71" y="20">dw</text>
	  </g>
	</g>
      </svg>
    </div>
  </td></tr>
<tr><td><code>.expand(<br>&nbsp; <u>dw</u>, <u>dh</u>, <u>anchor</u>='c')</code></td>
  <td>Creates an expanded rectangle by (<code>dw&times;2</code>, <code>dh&times;2</code>).
    <div style="margin-left:1em;">
      <svg xmlns="http://www.w3.org/2000/svg"
	   xmlns:xlink="http://www.w3.org/1999/xlink"
	   version="1.1" width="200" height="90">
	<marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
	  <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
	</marker>
	<g transform="translate(36.5,4.5)">
	  <g fill="none" stroke="black" stroke-width="1">
	    <rect x="30" y="30" width="40" height="20" />
	    <rect x="0" y="10" width="100" height="60" />
	    <line x1="0" y1="29" x2="100" y2="29" />
	    <line x1="0" y1="51" x2="100" y2="51" />
	    <line x1="29" y1="10" x2="29" y2="70" />
	    <line x1="71" y1="10" x2="71" y2="70" />
	    <g marker-end="url(#arrow)" stroke-width="2">
	      <line x1="25" y1="25" x2="5" y2="15" />
	      <line x1="75" y1="25" x2="95" y2="15" />
	      <line x1="25" y1="55" x2="5" y2="65" />
	      <line x1="75" y1="55" x2="95" y2="65" />
	      <line x1="25" y1="40" x2="5" y2="40" />
	      <line x1="75" y1="40" x2="95" y2="40" />
	      <line x1="50" y1="25" x2="50" y2="15" />
	      <line x1="50" y1="55" x2="50" y2="65" />
	    </g>
	  </g>
	  <g style="font-family: monospace;">
	    <text x="0" y="8" text-anchor="end">nw</text>
	    <text x="50" y="8" text-anchor="middle">n</text>
	    <text x="100" y="8" text-anchor="begin">ne</text>
	    <text x="0" y="45" text-anchor="end">w</text>
	    <text x="100" y="45" text-anchor="begin">e</text>
	    <text x="0" y="80" text-anchor="end">sw</text>
	    <text x="50" y="80" text-anchor="middle">s</text>
	    <text x="100" y="80" text-anchor="begin">se</text>
	  </g>
	</g>
      </svg>
    </div>
  </td></tr>
<tr><td><code>.resize(<br>&nbsp; <u>w</u>, <u>h</u>, <u>anchor</u>='c')</code></td>
  <td>Creates a resized rectangle.
    <div style="margin-left:1em;">
      <svg xmlns="http://www.w3.org/2000/svg"
	   xmlns:xlink="http://www.w3.org/1999/xlink"
	   version="1.1" width="200" height="90">
	<marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
	  <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
	</marker>
	<g transform="translate(36.5,4.5)">
	  <g fill="none" stroke="black" stroke-width="1">
	    <rect x="30" y="30" width="40" height="20" />
	    <rect x="0" y="10" width="100" height="60" />
	    <line x1="0" y1="29" x2="100" y2="29" />
	    <line x1="0" y1="51" x2="100" y2="51" />
	    <line x1="29" y1="10" x2="29" y2="70" />
	    <line x1="71" y1="10" x2="71" y2="70" />
	    <g marker-end="url(#arrow)" stroke-width="2">
	      <line x1="25" y1="25" x2="5" y2="15" />
	      <line x1="75" y1="25" x2="95" y2="15" />
	      <line x1="25" y1="55" x2="5" y2="65" />
	      <line x1="75" y1="55" x2="95" y2="65" />
	      <line x1="25" y1="40" x2="5" y2="40" />
	      <line x1="75" y1="40" x2="95" y2="40" />
	      <line x1="50" y1="25" x2="50" y2="15" />
	      <line x1="50" y1="55" x2="50" y2="65" />
	    </g>
	  </g>
	  <g style="font-family: monospace;">
	    <text x="0" y="8" text-anchor="end">nw</text>
	    <text x="50" y="8" text-anchor="middle">n</text>
	    <text x="100" y="8" text-anchor="begin">ne</text>
	    <text x="0" y="45" text-anchor="end">w</text>
	    <text x="100" y="45" text-anchor="begin">e</text>
	    <text x="0" y="80" text-anchor="end">sw</text>
	    <text x="50" y="80" text-anchor="middle">s</text>
	    <text x="100" y="80" text-anchor="begin">se</text>
	  </g>
	</g>
      </svg>
    </div>
  </td></tr>
<tr><td><code>.xdistance(<u>rect</u>)</code></td>
  <td>X-distance to <code>rect</code>.</td></tr>
<tr><td><code>.ydistance(<u>rect</u>)</code></td>
  <td>Y-distance to <code>rect</code>.</td></tr>
<tr><td><code>.containsRect(<u>rect</u>)</code></td>
  <td><code>true</code> if the rectangle contains <code>rect</code>.</td></tr>
<tr><td><code>.overlapsRect(<u>rect</u>)</code></td>
  <td><code>true</code> if the rectangle overlaps <code>rect</code>.</td></tr>
<tr><td><code>.overlapsCircle(<u>circle</u>)</code></td>
  <td><code>true</code> if the rectangle overlaps <code>circle</code>.</td></tr>
<tr><td><code>.union(<u>rect</u>)</code></td>
  <td>Combines two rectangles (union).</td></tr>
<tr><td><code>.intersection(<u>rect</u>)</code></td>
  <td>Combines two rectangles (intersection).</td></tr>
<tr><td><code>.clamp(<u>bounds</u>)</code></td>
  <td>Moves the rectangle so that it fits <code>bounds</code>.</td></tr>
<tr><td><code>.modPt(<u>p</u>)</code></td>
  <td>Creates a modulo point with the rectangle.</td></tr>
<tr><td><code>.contactRect(<u>v</u>, <u>rect</u>)</code></td>
  <td>Trims a vector so that <code>rect</code> doesn't collide with this.</td></tr>
<tr><td><code>.boundRect(<u>v</u>, <u>rect</u>)</code></td>
  <td>Trims a vector so that <code>rect</code> is restricted inside this.</td></tr>
</table>

<a name="Circle"><h3>Circle : <a href="#Shape">Shape</a> (<code><a href="https://github.com/euske/euskit/blob/master/base/geom.ts">geom.ts</a></code>)</h3></a>
<p>
A <code>Circle</code> represents a circle that has its center and radius.
<table border>
<tr class=ctor><td><code>new Circle(<u>center</u>, <u>radius</u>=0)</code></td>
  <td>New circle with the given center and radius.</td></tr>
<tr><td><code>.center</code></td>
  <td>Center of the circle.</td></tr>
<tr><td><code>.radius</code></td>
  <td>Radius of the circle.</td></tr>
<tr><td><code>.inflate(<u>dr</u>)</code></td>
  <td>Creates a inflated/deflated circle by <code>dr</code>.</tr></tr>
<tr><td><code>.resize(<u>radius</u>)</code></td>
  <td>Creates a resized circle.</tr></tr>
<tr><td><code>.distance(<u>p</u>)</code></td>
  <td>Distance to point <code>p</code>.</td></tr>
<tr><td><code>.containsCircle(<u>circle</u>)</code></td>
  <td><code>true</code> if the circle contains another <code>circle</code>.</td></tr>
<tr><td><code>.overlapsCircle(<u>circle</u>)</code></td>
  <td><code>true</code> if the circle overlaps another <code>circle</code>.</td></tr>
<tr><td><code>.overlapsRect(<u>rect</u>)</code></td>
  <td><code>true</code> if the circle overlaps <code>rect</code>.</td></tr>
<tr><td><code>.clamp(<u>bounds</u>)</code></td>
  <td>Moves the circle so that it fits <code>bounds</code>.</td></tr>
<tr><td><code>.contactCircle(<u>v</u>, <u>circle</u>)</code></td>
  <td>Trims a vector so that <code>circle</code> doesn't collide with this.</td></tr>
</table>

<a name="AAPlane"><h3>AAPlane (<code><a href="https://github.com/euske/euskit/blob/master/base/geom.ts">geom.ts</a></code>)</h3></a>
<p>
A <code>AAPlane</code> represents an axis-aligned plane.
It is represented by two axis-aligned (either X, Y or Z) points.
If two points are not aligned by any axis, it is invalid.
<table border>
<tr class=ctor><td><code>new AAPlane(<u>p0</u>, <u>p1</u>)</code></td>
  <td>New AAPlane for the given points.</td></tr>
<tr><td><code>.p0</code></td>
  <td>Point 0.</td></tr>
<tr><td><code>.p1</code></td>
  <td>Point 1.</td></tr>
</table>

<a name="Box"><h3>Box (<code><a href="https://github.com/euske/euskit/blob/master/base/geom.ts">geom.ts</a></code>)</h3></a>
<p>
A <code>Box</code> is a 3D cuboid that has its position and size
both as <code>Vec3</code>.
<table border>
<tr class=ctor><td><code>new Box(<u>origin</u>, <u>size</u>=null)</code></td>
  <td>New Box with (<code>origin</code>, <code>size</code>).</td></tr>
<tr><td><code>.origin</code></td>
  <td>Origin of the box.</td></tr>
<tr><td><code>.size</code></td>
  <td>Size of the box.</td></tr>
<tr><td><code>.copy()</code></td>
  <td>Duplicates the box.</td></tr>
<tr><td><code>.equals(<u>box</u>)</code></td>
  <td><code>true</code> if <code>box</code> is identical.</td></tr>
<tr><td><code>.isZero()</code></td>
  <td><code>true</code> if the box is empty.</td></tr>
<tr><td><code>.center()</code></td>
  <td>Center of the box.</td></tr>
<tr><td><code>.surface(<u>vx</u>, <u>vy</u>, <u>vz</u>)</code></td>
  <td>Returns the <code>AAPlane</code> of the given surface.</td></tr>
<tr><td><code>.anchor(<u>vx</u>=0, <u>vy</u>=0, <u>vz</u>=0)</code></td>
  <td>Anchor point of the box.</td></tr>
<tr><td><code>.move(<u>dx</u>, <u>dy</u>, <u>dz</u>)</code></td>
  <td>Creates a box moved by (<code>dx</code>, <code>dy</code>, <code>dz</code>).</td></tr>
<tr><td><code>.add(<u>v</u>)</code></td>
  <td>Creates a box moved by <code>v</code>.</td></tr>
<tr><td><code>.sub(<u>v</u>)</code></td>
  <td>Creates a box moved by <code>-v</code>.</td></tr>
<tr><td><code>.inflate(<u>dx</u>, <u>dy</u>, <u>dz</u>)</code></td>
  <td>Creates a inflated/deflated box by (<code>dx</code>, <code>dy</code>, <code>dz</code>).</td></tr>
<tr><td><code>.xdistance(<u>box</u>)</code></td>
  <td>X-distance to <code>box</code>.</td></tr>
<tr><td><code>.ydistance(<u>box</u>)</code></td>
  <td>Y-distance to <code>box</code>.</td></tr>
<tr><td><code>.zdistance(<u>box</u>)</code></td>
  <td>Z-distance to <code>box</code>.</td></tr>
<tr><td><code>.union(<u>box</u>)</code></td>
  <td>Combines two boxes (union).</td></tr>
<tr><td><code>.intersection(<u>box</u>)</code></td>
  <td>Combines two boxes (intersection).</td></tr>
<tr><td><code>.clamp(<u>bounds</u>)</code></td>
  <td>Moves the box so that it fits <code>bounds</code>.</td></tr>
<tr><td><code>.rndPt()</code></td>
  <td>Creates a random point within the box.</td></tr>
<tr><td><code>.containsPt(<u>p</u>)</code></td>
  <td><code>true</code> if the box contains <code>p</code>.</td></tr>
<tr><td><code>.overlapsBox(<u>box</u>)</code></td>
  <td><code>true</code> if the box overlaps <code>box</code>.</td></tr>
<tr><td><code>.contactBox(<u>v</u>, <u>box</u>)</code></td>
  <td>Trims a vector so that <code>box</code> doesn't collide with this.</td></tr>
<tr><td><code>.union(<u>box</u>)</code></td>
  <td>Combines two boxes (union).</td></tr>
<tr><td><code>.intersection(<u>box</u>)</code></td>
  <td>Combines two boxses (intersection).</td></tr>
<tr><td><code>.clamp(<u>bounds</u>)</code></td>
  <td>Moves the box so that it fits <code>bounds</code>.</td></tr>
</table>

<a name="TileMap"><h3>TileMap (<code><a href="https://github.com/euske/euskit/blob/master/base/tilemap.ts">tilemap.ts</a></code>)</h3></a>
<p>
A <code>TileMap</code> represents a two-dimensional array that holds map tiles.
<table border>
<tr class=ctor><td><code>new TileMap(<br>&nbsp; <u>tilesize</u>, <u>width</u>, <u>height</u>, <br>&nbsp; <u>map</u>=null)</code></td>
  <td>New TileMap for a given size.</td></tr>
<tr><td><code>.tilesize</code></td>
  <td>Tile size.</td></tr>
<tr><td><code>.width</code></td>
  <td>Number of tiles that fit horizontally in the map.</td></tr>
<tr><td><code>.height</code></td>
  <td>Number of tiles that fit vertically in the map.</td></tr>
<tr><td><code>.bounds</code></td>
  <td>Bounds of the map in the actual size.</td></tr>
<tr><td><code>.map</code></td>
  <td>Int32Array[] for the map data. Optionally given at construction.</td></tr>
<tr><td><code>.get(<u>x</u>, <u>y</u>)</code></td>
  <td>Gets a tile at a specific position.</td></tr>
<tr><td><code>.set(<u>x</u>, <u>y</u>, <u>c</u>)</code></td>
  <td>Sets a tile at a specific position. (Clears the RangeMap cache.)</td></tr>
<tr><td><code>.fill(<u>c</u>, <u>rect</u>=null)</code></td>
  <td>Fills tiles in a given area.</td></tr>
<tr><td><code>.copy()</code></td>
  <td>Copies the tilemap.</td></tr>
<tr><td><code>.coord2map(<u>rect</u>)</code></td>
  <td>Converts an actual Rect/Vec2 to the tile cells.</td></tr>
<tr><td><code>.map2coord(<u>rect</u>)</code></td>
  <td>Converts a Rect/Vec2 for tile cells to the actual size.</td></tr>
<tr><td><code>.apply(<br>&nbsp; <u>(x,y,c) =&gt; boolean</u>,<br>&nbsp; <u>rect</u>=null)</code></td>
  <td>Applies a function to tiles.</td></tr>
<tr><td><code>.shift(<u>vx</u>, <u>vy</u>, <u>rect</u>=null)</code></td>
  <td>Shift all the cells in the given area.</td></tr>
<tr><td><code>.findTile(<br>&nbsp; <u>(c) =&gt; boolean</u>, <br>&nbsp; <u>rect</u>=null)</code></td>
  <td>Returns the position of the first tile in the given area.</td></tr>
<tr><td><code>.findTileByCoord(<br>&nbsp; <u>(c) =&gt; boolean</u>, <br>&nbsp; <u>range</u>)</code></td>
  <td>Returns the position of the first tile in the given area.</td></tr>
<tr><td><code>.getTileRects(<br>&nbsp; <u>(c) =&gt; boolean</u>, <br>&nbsp; <u>range</u>)</code></td>
  <td>Returns a list of actual rectangles for tiles.</td></tr>
<tr><td><code>.getRangeMap(<br>&nbsp; <u>key</u>, <br>&nbsp; <u>(c) =&gt; boolean</u>)</code></td>
  <td>Creates a <code>RangeMap</code> object for this tilemap.</td></tr>
<tr><td><code>.renderFromBottomLeft(<br>&nbsp; <u>ctx</u>, <u>ft</u>,<br>&nbsp; <u>x0</u>=0, <u>y0</u>=0, <u>w</u>=0, <u>h</u>=0)</code></td>
  <td>Renders the tiles from bottom left for a given tile set.</td></tr>
<tr><td><code>.renderFromTopRight(<br>&nbsp; <u>ctx</u>, <u>ft</u>,<br>&nbsp; <u>x0</u>=0, <u>y0</u>=0, <u>w</u>=0, <u>h</u>=0)</code></td>
  <td>Renders the tiles from top right for a given tile set.</td></tr>
<tr><td><code>.renderWindowFromBottomLeft(<br>&nbsp; <u>ctx</u>, <u>window</u>, <u>ft</u>)</code></td>
  <td>Renders the tiles from bottom left within a window.</td></tr>
<tr><td><code>.renderWindowFromTopRight(<br>&nbsp; <u>ctx</u>, <u>window</u>, <u>ft</u>)</code></td>
  <td>Renders the tiles from top right within a window.</td></tr>
</table>

<a name="RangeMap"><h3>RangeMap (<code><a href="https://github.com/euske/euskit/blob/master/base/tilemap.ts">tilemap.ts</a></code>)</h3></a>
<p>
A <code>RangeMap</code> is a partial copy of <code>TileMap</code>
that allows range queries for specific tiles.<br>
<strong>Note:</strong>
This object is always returned by <code>TileMap.getRangeMap()</code> method
and not explicitly created by a user.
<table border>
<tr><td><code>.width</code></td>
  <td>Number of tiles that fit horizontally in the map.</td></tr>
<tr><td><code>.height</code></td>
  <td>Number of tiles that fit vertically in the map.</td></tr>
<tr><td><code>.get(<u>x0</u>, <u>y0</u>, <u>x1</u>, <u>y1</u>)</code></td>
  <td>Returns the number of specific tiles within the given area.</td></tr>
<tr><td><code>.exists(<u>rect</u>)</code></td>
  <td><code>true</code> if a specific tile exists within the given area.</td></tr>
</table>

<a name="SpriteSheet"><h3>SpriteSheet (<code><a href="https://github.com/euske/euskit/blob/master/base/sprite.ts">sprite.ts</a></code>)</h3></a>
<p>
A set of <code>Sprite</code> objects indexed by a number.
<table border>
<tr class=ctor><td><code>new ImageSpriteSheet(image, size, <em>[origin]</em>)</code></td>
  <td>Creates a <code>SpriteSheet</code> from <code>&lt;img&gt;</code>.</td></tr>
<tr class=ctor><td><code>new ArraySpriteSheet(sprites)</code></td>
  <td>Creates a <code>SpriteSheet</code> from an array of <code>Sprite</code>s.</td></tr>
<tr><td><code>.get(i, <em>[j, [w, [h, [origin]]]]</em>)</code></td>
  <td>Returns the <code>i,j</code>-th <code>Sprite</code>.</td></tr>
</table>

<a name="PhysicsConfig"><h3>PhysicsConfig (<code><a href="https://github.com/euske/euskit/blob/master/base/entity.ts">entity.ts</a></code>)</h3></a>
<p>
<table border>
<tr class=ctor><td><code>new PhysicsConfig()</code></td>
  <td>Creates a new configuration.</td></tr>
<tr><td><code>.maxspeed</code></td>
  <td>Vector for the maximum speed (absolute values).</td></tr>
<tr><td><code>.jumpfunc</code></td>
  <td>Gravity function <code>(vy, t) =&gt; number</code></td></tr>
<tr><td><code>.isObstacle</code></td>
  <td>Function <code>(c) =&gt; boolean</code> that returns true if the tile is an obstacle.</td></tr>
<tr><td><code>.isGrabbable</code></td>
  <td>Function <code>(c) =&gt; boolean</code> that returns true if the tile is grabbable (e.g. ladders).</td></tr>
<tr><td><code>.isStoppable</code></td>
  <td>Function <code>(c) =&gt; boolean</code> that returns true if the tile is stoppable.</td></tr>
</table>

<a name="TaskList"><h3>TaskList (<code><a href="https://github.com/euske/euskit/blob/master/base/task.ts">task.ts</a></code>)</h3></a>
<p>
Manages a list of <code>Task</code>s.
<table border>
<tr class=ctor><td><code>new ParallelTaskList()</code></td>
  <td>Tasklist that runs given tasks parallelly.</td></tr>
<tr class=ctor><td><code>new SequentialTaskList()</code></td>
  <td>Tasklist that runs given tasks sequentially.</td></tr>
<tr><td><code>.onStart()</code></td>
  <td>Initializes the task list.</td></tr>
<tr><td><code>.onTick()</code></td>
  <td>Invoked at every frame. Update the current tasks.</td></tr>
<tr><td><code>.add(task)</code></td>
  <td>Adds a task to the list.</td></tr>
<tr><td><code>.remove(task)</code></td>
  <td>Removes a task from the list.</td></tr>
<tr><td><code>.stopWhenEmpty</code></td>
  <td>Set <code>true</code> to automatically kill the queue when there's no <code>Task</code>.</td></tr>
</table>

<a name="functions"><h2>Functions</h2></a>

<a name="main"><h3>Main function (<code>main.ts</code>)</h3></a>
<table border>
<tr><td><code>APP</td>
  <td>Global <code>App</code> instance.</td></tr>
<tr><td><code>addInitHook(<u>() =&gt; {}</u>)</td>
  <td>Has a hook executed after the page is loaded.</td></tr>
<tr><td><code>main(<br>&nbsp; <u>ctor</u>, <u>width</u>=320, <u>height</u>=240,<br>&nbsp; <u>canvasId</u>='game', <u>framerate</u>=30)</code></td>
  <td>Specifies the canvas size and the initial constructor of a <code>Scene</code> object.
    (without arg)</td></tr>
</table>

<h4>How to Use</h4>
<blockquote><pre class=code>
&lt;script&gt;
  class Scene1 extends Scene { ... }
&lt;/script&gt;
&lt;body onload="main(Scene1, 'game', 320, 240, 30);"&gt;
&lt;div id="main" style="width:640px; height:480px"&gt;&lt;/div&gt;
</pre></blockquote>

<a name="misc"><h3>Misc. functions (<code><a href="https://github.com/euske/euskit/blob/master/base/utils.ts">utils.ts</a></code>)</h3></a>
<table border>
<tr><td><code>log(<u>msg</u>, ...)</code></td>
  <td>Displays the messages to the console.</td></tr>
<tr><td><code>assert(<u>cond</u>, <u>msg</u>="assertion error")</code></td>
  <td>Throws an exception when the condition is not met.</td></tr>
<tr><td><code>applyMixins(<u>ctor</u>, <u>bases</u>)</code></td>
  <td>Configures a new class.</td></tr>
</table>

<a name="numeric"><h3>Numeric functions (<code><a href="https://github.com/euske/euskit/blob/master/base/utils.ts">utils.ts</a></code>)</h3></a>
<table border>
<tr><td><code>fmod(<u>x</u>, <u>y</u>)</code></td>
  <td>Better <code>mod</code> function; i.e. <code>fmod(-3,2)=1</code>.</td></tr>
<tr><td><code>int(<u>x</u>)</code></td>
  <td>Equivalent to <code>Math.floor</code>.</td></tr>
<tr><td><code>upperbound(<u>x</u>, <u>y</u>)</code></td>
  <td>Limits a value to min(<code>x</code>, <code>y</code>).</td></tr>
<tr><td><code>lowerbound(<u>x</u>, <u>y</u>)</code></td>
  <td>Limits a value to max(<code>x</code>, <code>y</code>).</td></tr>
<tr><td><code>clamp(<u>v0</u>, <u>v</u>, <u>v1</u>)</code></td>
  <td>Limits a value within [<code>v0</code>, <code>v1</code>].</td></tr>
<tr><td><code>sign(<u>v</u>)</code></td>
  <td>Returns -1, 0 or +1 based on the sign of <code>v</code>.</td></tr>
<tr><td><code>phase(<u>t</u>, <u>interval</u>, <u>n</u>=2)</code></td>
  <td>Returns the phase for time <code>t</code>.</td></tr>
<tr><td><code>frnd(<u>a</u>, <u>b</u>=0)</code></td>
  <td>Generates a value [0,<code>a</code>) or [<code>a</code>,<code>b</code>)</td></tr>
<tr><td><code>rnd(<u>a</u>, <u>b</u>=0)</code></td>
  <td>Generates an integer value [0,<code>a</code>) or [<code>a</code>,<code>b</code>)</td></tr>
<tr><td><code>getTime()</code></td>
  <td>Returns the current time in seconds.</td></tr>
<tr><td><code>format(<u>v</u>, <u>n</u>=3, <u>c</u>=' ')</code></td>
  <td>Formats a number as a string.</td></tr>
</table>

<a name="array"><h3>Array functions (<code><a href="https://github.com/euske/euskit/blob/master/base/utils.ts">utils.ts</a></code>)</h3></a>
<table border>
<tr><td><code>choice(<u>a</u>)</code></td>
  <td>Returns a random element of <code>a</code>.</td></tr>
<tr><td><code>removeElement(<u>a</u>, <u>obj</u>)</code></td>
  <td>Removes an element from <code>a</code>.</td></tr>
<tr><td><code>range(<u>n</u>)</code></td>
  <td>Returns an array filled with a sequence [0, <code>n</code>-1].</td></tr>
<tr><td><code>str2array(<u>img</u>)</code></td>
  <td>Converts a string to a number array.</td></tr>
<tr><td><code>makeMatrix(<u>rows</u>, <u>cols</u>, <u>value</u>=0)</code></td>
  <td>Creates a 2D matrix for a given size.</td></tr>
</table>

<a name="html5"><h3>HTML5 functions (<code><a href="https://github.com/euske/euskit/blob/master/base/utils.ts">utils.ts</a></code>)</h3></a>
<table border>
<tr><td><code>removeChildren(<u>node</u>, <u>name</u>)</code></td>
  <td>Removes all child HTML nodes.</td></tr>
<tr><td><code>createCanvas(<u>width</u>, <u>height</u>)</code></td>
  <td>Creates a <code>&lt;canvas&gt;</code> element.</td></tr>
<tr><td><code>getEdgeyContext(<u>canvas</u>)</code></td>
  <td>Creates a <code>CanvasRenderingContext2D</code>.</td></tr>
<tr><td><code>image2array(<u>img</u>)</code></td>
  <td>Converts an image to an 2D array.</td></tr>
<tr><td><code>fillRect(<u>ctx</u>, <u>rect</u>)</code></td>
  <td>Fills a rectangle.</td></tr>
<tr><td><code>strokeRect(<u>ctx</u>, <u>rect</u>)</code></td>
  <td>Draws a rectangle.</td></tr>
<tr><td><code>ellipse(<u>ctx</u>, <u>cx</u>, <u>cy</u>, <u>rx</u>, <u>ry</u>)</code></td>
  <td>Draws an ellipse at (cx, cy).</td></tr>
<tr><td><code>drawImageScaled(<br>&nbsp; <u>ctx</u>, <u>img</u>,<br>&nbsp; <u>sx</u>, <u>sy</u>, <u>sw</u>, <u>sh</u>,<br>&nbsp; <u>dx</u>, <u>dy</u>, <u>dw</u>, <u>dh</u>)</code></td>
  <td>Draws a flipped image.</td></tr>
<tr><td><code>getKeySym(<u>keycode</u>)</code></td>
  <td>Returns the <code>KeySym</code> for <code>keyCode</code>.</td></tr>
</table>

</div>
</div> <!-- main -->
