<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<style>
h1 { border-bottom: 4px solid; margin: 0; }
h2 { color: white; background: #880000; border-bottom: 2px solid black; }
h3 { background: #ffccff; border-bottom: 1px solid; }
table { border-collapse: collapse; }
td { padding: 2px; }
a { font-weight: bold; }
body { margin: 0; padding: 0; }
.code { border: 1px solid; padding: 0.2em; background: #eeeeee; }
.ctor { background: #ffffcc; }
.inherited { background: #cccccc; }
.overridable { background: #ccffcc; }
.nav { position: fixed; top: 0; left: 0; width: 20%; }
.main { position: absolute; top: 0; left: 20%; width: 80%; }
.list { margin-top: 1em; }
.list > .head { font-weight: bold; background: #88ffff; }
.navhead { font-size: 150%; font-weight: bold; }
</style>
<title>Euskit Quick Reference</title>
</head>
<body>

<div class=nav>
<div style="padding: 0.5em;">

<div class=navhead><a href="https://github.com/euske/euskit">Euskit</a></div>

<p>
Legend:
<span class=ctor><code>constructor</code></span>,
<span class=inherited><code>inherited method</code></span>,
<span class=overridable><code>overridable method</code></span>

<div class=list>
<div class=head>Functions:</div>
<a href="#main">Main</a>,
<a href="#misc">Misc.</a>,
<a href="#numeric">Numeric</a>,
<a href="#array">Array</a>,
<a href="#html5">HTML5</a>
</div>

<div class=list>
<div class=head>Utility Classes:</div>
<a href="#Signal"><code>Signal</code></a>,
<a href="#Color"><code>Color</code></a>,
<a href="#Vec2"><code>Vec2</code></a>,
<a href="#Vec3"><code>Vec3</code></a>,
<a href="#Shape"><code>Shape</code></a>,
<a href="#Collider"><code>Collider</code></a>,
<a href="#Rect"><code>Rect</code></a>,
<a href="#Circle"><code>Circle</code></a>,
<a href="#Box"><code>Box</code></a>,
<a href="#TileMap"><code>TileMap</code></a>,
<a href="#RangeMap"><code>RangeMap</code></a>,
<a href="#ImageSource"><code>ImageSource</code></a>,
<a href="#SpriteSheet"><code>SpriteSheet</code></a>,
<a href="#Sprite"><code>Sprite</code></a>
</div>

<div class=list>
<div class=head>Basic Classes:</div>
<a href="#Task"><code>Task</code></a>,
<a href="#Entity"><code>Entity</code></a>,
<a href="#Layer"><code>Layer</code></a>,
<a href="#Scene"><code>Scene</code></a>,
<a href="#App"><code>App</code></a>
</div>

<div class=list>
<div class=head>Specialized Classes:</div>
<a href="#Projectile"><code>Projectile</code></a>,
<a href="#TiledSprite"><code>TiledSprite</code></a>,
<a href="#FlowSprite"><code>FlowSprite</code></a>,
<a href="#PhysicalEntity"><code>PhysicalEntity</code></a>,
<a href="#PlatformerEntity"><code>PlatformerEntity</code></a>,
<a href="#ScrollLayer"><code>ScrollLayer</code></a>,
<a href="#GameScene"><code>GameScene</code></a>,
<a href="#HTMLScene"><code>HTMLScene</code></a>
</div>

<div class=list>
<div class=head>Text Library:</div>
<a href="#Font"><code>Font</code></a>,
<a href="#ShadowFont"><code>ShadowFont</code></a>,
<a href="#TextBox"><code>TextBox</code></a>,
<a href="#DialogBox"><code>DialogBox</code></a>
</div>

<div class=list>
<div class=head>Animation Library:</div>
<a href="#Queue"><code>Queue</code></a>
</div>

<div class=list>
<div class=head>Pathfinding Library:</div>
<a href="#PlanActor"><code>PlanActor</code></a>,
<a href="#PlanAction"><code>PlanAction</code></a>,
<a href="#PlanProfile"><code>PlanProfile</code></a>,
<a href="#PlanMap"><code>PlanMap</code></a>,
<a href="#PlanActionRunner"><code>PlanActionRunner</code></a>,
<a href="#PlanningEntity"><code>PlanningEntity</code></a>
</div>

</div>
</div>

<div class=main>
<div style="padding: 0.5em;">

<h1>API Quick Reference</h1>

<a name="concepts"><h2>Concepts</h2></a>
<div style="position: relative;">
  <svg xmlns="http://www.w3.org/2000/svg" 
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="250" height="150">
    <g transform="translate(1.5,1.5)">
      <g fill="none" stroke="black" stroke-width="1">
	<line x1="140" y1="12" x2="55" y2="100" />
	<line x1="140" y1="12" x2="175" y2="100" />
	<rect x="0" y="55" width="110" height="92" fill="white" />
	<rect x="120" y="55" width="110" height="92" fill="white" />
	<ellipse cx="140" cy="12" rx="20" ry="12" fill="white" />
	<rect x="18" y="60" width="80" height="60" fill="white" />
	<rect x="14" y="64" width="80" height="60" fill="white" />
	<rect x="10" y="68" width="80" height="60" fill="white" />
	<circle cx="20" cy="80" r="5" />
	<rect x="30" y="110" width="16" height="16" />
	<rect x="33" y="113" width="10" height="10" />
	<line x1="45" y1="102" x2="38" y2="118" />
      </g>
      <g style="font-size: 75%;">
	<text x="140" y="15" text-anchor="middle">App</text>
	<text x="28" y="85" text-anchor="begin">Task</text>
	<text x="45" y="102" text-anchor="begin">Sprite</text>
	<text x="48" y="122" text-anchor="begin">Entity</text>
	<text x="70" y="140" text-anchor="begin">Layer</text>
	<text x="55" y="52" text-anchor="middle">Scene</text>
	<text x="175" y="52" text-anchor="middle">Scene</text>
	<text x="240" y="100" text-anchor="begin">...</text>
	<text x="165" y="15">Images, ...</text>
      </g>
    </g>
  </svg>
  <div style="position: absolute; left: 270px; top: 0px;">
    <a href="#App"><code>App</code></a>: 
    Manages global states and shared resources (images and sounds).<br>
    <a href="#Scene"><code>Scene</code></a>: 
    Handles input events and character movements.<br>
    <a href="#Layer"><code>Layer</code></a>: 
    Contains a set of <code>Task</code>/<code>Sprite</code>/<code>Entity</code>.<br>
    <a href="#Task"><code>Task</code></a>: 
    A process that gets called for every frame.<br>
    <a href="#Entity"><code>Entity</code></a>: 
    A <code>Task</code> that can collide another <code>Entity</code>.<br>
    <a href="#Sprite"><code>Sprite</code></a>: 
    A visible object that belongs to a layer.<br>
  </div>
</div>

<a name="functions"><h2>Functions</h2></a>

<a name="main"><h3>Main function (<code>main.ts</code>)</h3></a>
<table border>
<tr><td><code>APP</td>
  <td>The global App instance.</td></tr>
<tr><td><code>IMAGES</td>
  <td>The global image reources.</td></tr>
<tr><td><code>SOUNDS</td>
  <td>The global sound reources.</td></tr>
<tr><td><code>TEXTS</td>
  <td>The global text reources.</td></tr>
<tr><td><code>addInitHook(hook)</td>
  <td>Add a hook that is executed after the page load is complete.</td></tr>
<tr><td><code>main(ctor, <em>[width, [height,<br>&nbsp; [canvasId, [framerate]]]]</em>)</code></td>
  <td>Starts an app from the specified Scene.</td></tr>
</table>

<h4>How to Use</h4>
<blockquote><pre class=code>
&lt;script&gt;
  class Scene1 extends Scene { ... }
&lt;/script&gt;
&lt;body onload="main(Scene1, 'game', 320, 240, 30);"&gt;
&lt;div id="main" style="width:640px; height:480px"&gt;&lt;/div&gt;
</pre></blockquote>

<a name="misc"><h3>Misc. functions (<code>utils.ts</code>)</h3></a>
<table border>
<tr><td><code>log(...)</code></td>
  <td>Log the messages to the console.</td></tr>
<tr><td><code>assert(x, <em>msg="assertion error"</em>)</code></td>
  <td>Throws an exception when the condition is not met.</td></tr>
<tr><td><code>applyMixins(ctor, bases)</code></td>
  <td>Configures a new class.</td></tr>
</table>

<a name="numeric"><h3>Numeric functions (<code>utils.ts</code>)</h3></a>
<table border>
<tr><td><code>fmod(x, y)</code></td>
  <td>Equivalent to <code>fmod</code> C function.</td></tr>
<tr><td><code>int(x)</code></td>
  <td>Equivalent to <code>Math.floor</code>.</td></tr>
<tr><td><code>upperbound(x, y)</code></td>
  <td>Limits a value to min(<code>x</code>, <code>y</code>).</td></tr>
<tr><td><code>lowerbound(x, y)</code></td>
  <td>Limits a value to max(<code>x</code>, <code>y</code>).</td></tr>
<tr><td><code>clamp(v0, v, v1)</code></td>
  <td>Limits a value within [<code>v0</code>, <code>v1</code>].</td></tr>
<tr><td><code>sign(v)</code></td>
  <td>Returns -1, 0 or +1 based on the sign of <code>v</code>.</td></tr>
<tr><td><code>phase(t, interval, <em>n=2</em>)</code></td>
  <td>Returns the phase for time <code>t</code>.</td></tr>
<tr><td><code>frnd(a, <em>b=0</em>)</code></td>
  <td>Generates a value [0,<code>a</code>) or [<code>a</code>,<code>b</code>)</td></tr>
<tr><td><code>rnd(a, <em>b=0</em>)</code></td>
  <td>Generates an integer value [0,<code>a</code>) or [<code>a</code>,<code>b</code>)</td></tr>
<tr><td><code>getTime()</code></td>
  <td>Returns the current time in seconds.</td></tr>
<tr><td><code>format(v, <em>n=3, c=' '</em>)</code></td>
  <td>Formats a number as a string.</td></tr>
</table>

<a name="array"><h3>Array functions (<code>utils.ts</code>)</h3></a>
<table border>
<tr><td><code>choice(a)</code></td>
  <td>A random element of <code>a</code>.</td></tr>
<tr><td><code>removeElement(a, obj)</code></td>
  <td>Removes an element from <code>a</code>.</td></tr>
<tr><td><code>range(n)</code></td>
  <td>Returns an array filled with a sequence [0, <code>n</code>-1].</td></tr>
<tr><td><code>str2array(img)</code></td>
  <td>Converts a string to a number array.</td></tr>
</table>

<a name="html5"><h3>HTML5 functions (<code>utils.ts</code>)</h3></a>
<table border>
<tr><td><code>removeChildren(node, name)</code></td>
  <td>Removes all child HTML nodes.</td></tr>
<tr><td><code>createCanvas(width, height)</code></td>
  <td>Creates a <code>&lt;canvas&gt;</code> element.</td></tr>
<tr><td><code>getEdgeyContext(canvas)</code></td>
  <td>Creates a <code>CanvasRenderingContext2D</code>.</td></tr>
<tr><td><code>image2array(img)</code></td>
  <td>Converts an image to an 2D array.</td></tr>
<tr><td><code>drawImageScaled(<br>&nbsp; ctx, imgsrc,<br>&nbsp; sx, sy, sw, sh,<br>&nbsp; dx, dy, dw, dh)</code></td>
  <td>Draws a flipped image.</td></tr>
<tr><td><code>ellipse(ctx, cx, cy, rx, ry)</code></td>
  <td>Draws an ellipse at (cx, cy).</td></tr>
<tr><td><code>playSound(sound, <em>start=0.025</em>)</code></td>
  <td>Plays a sound.</td></tr>
<tr><td><code>getKeySym(keyCode)</code></td>
  <td>Returns the <code>KeySym</code> for <code>keyCode</code>.</td></tr>
</table>

<a name="utility-classes"><h2>Utility Classes</h2></a>

<a name="Signal"><h3>Signal (<code>utils.ts</code>)</h3></a>
<p>
A <code>Signal</code> represents an event that is attached to a 
certain object and other objects can get notified.
<table border>
<tr class=ctor><td><code>new Signal(... <em>baseargs</em>)</code></td>
  <td>Creates a <code>Signal</code> with given <code>baseargs</code>.</td></tr>
<tr><td><code>.receivers</code></td>
  <td>A list of the receiver functions.</td></tr>
<tr><td><code>.subscribe(receiver)</code></td>
  <td>Adds <code>receiver</code> to the subscriber list.</td></tr>
<tr><td><code>.unsubscribe(receiver)</code></td>
  <td>Removes <code>receiver</code> from the subscriber list.</td></tr>
<tr><td><code>.fire(... <em>extraargs</em>)</code></td>
  <td>Sends a message to all the subscribers.
    Each receiver function gets (<code>baseargs</code> + <code>extraargs</code>)
    for arguments.</td></tr>
</table>

<a name="Color"><h3>Color (<code>utils.ts</code>)</h3></a>
<p>
A <code>Color</code> represents an RGBA value.
<table border>
<tr class=ctor><td><code>new Color(r, g, b, <em>[a]</em>)</code></td>
  <td>Creates a <code>Color</code> for RGBA values.</td></tr>
<tr><td><code>.r</code></td>
  <td>The red value.</td></tr>
<tr><td><code>.g</code></td>
  <td>The green value.</td></tr>
<tr><td><code>.b</code></td>
  <td>The blue value.</td></tr>
<tr><td><code>.a</code></td>
  <td>The alpha value.</td></tr>
<tr><td><code>.setAlpha(a)</code></td>
  <td>Creates a <code>Color</code> with a given alpha.</td></tr>
<tr><td><code>Color.generate(h, <em>v=1.0</em>)</code></td>
  <td>Creates a <code>Color</code> with a given hue.</td></tr>
</table>

<a name="Vec2"><h3>Vec2 (<code>geom.ts</code>)</h3></a>
<p>
A <code>Vec2</code> represents two-dimensional vector that has (x, y) elements.
<table border>
<tr class=ctor><td><code>new Vec2(<em>x=0, y=0</em>)</code></td>
  <td>Creates a vector (<code>x</code>, <code>y</code>).</td></tr>
<tr><td><code>.x</code></td>
  <td>The x value.</td></tr>
<tr><td><code>.y</code></td>
  <td>The y value.</td></tr>
<tr><td><code>.copy()</code></td>
  <td>Duplicates the vector.</td></tr>
<tr><td><code>.equals(p)</code></td>
  <td><code>true</code> if the vector is identical to <code>p</code>.</td></tr>
<tr><td><code>.isZero()</code></td>
  <td><code>true</code> if the vector is zero length.</td></tr>
<tr><td><code>.len2()</code></td>
  <td>The length<sup>2</sup> of the vector.</td></tr>
<tr><td><code>.len()</code></td>
  <td>The length of the vector.</td></tr>
<tr><td><code>.sign()</code></td>
  <td>(<code>sign(x)</code>, <code>sign(y)</code>).</td></tr>
<tr><td><code>.add(v)</code></td>
  <td>(<code>this</code> + <code>v</code>).</td></tr>
<tr><td><code>.sub(v)</code></td>
  <td>(<code>this</code> - <code>v</code>).</td></tr>
<tr><td><code>.scale(n)</code></td>
  <td>(<code>n</code> &sdot; <code>this</code>).</td></tr>
<tr><td><code>.distance(p)</code></td>
  <td>|<code>this</code> - <code>p</code>|.</td></tr>
<tr><td><code>.clamp(bounds)</code></td>
  <td>(<code>clamp(x)</code>, <code>clamp(y)</code>).</td></tr>
<tr><td><code>.move(dx, dy)</code></td>
  <td>(<code>x+dx</code>, <code>y+dy</code>).</td></tr>
<tr><td><code>.interpolate(p, t)</code></td>
  <td>(<code>this*(1-t) + p*t)</code>.</td></tr>
<tr><td><code>.rotate(d)</code></td>
  <td>Creates a rotated vector in radian (clockwise...0&lt;<code>d</code>)</td></tr>
<tr><td><code>.rot90(d)</code></td>
  <td>Creates a rotated vector by 90 degrees (clockwise...0&lt;<code>d</code>)</td></tr>
<tr><td><code>.expand(dw, dh, <em>vx=0, vy=0</em>)</code></td>
  <td>Creates a <code>Rect</code> with the point as an anchor.</td></tr>
</table>

<a name="Vec3"><h3>Vec3 (<code>geom.ts</code>)</h3></a>
<p>
A <code>Vec3</code> represents three-dimensional vector that has (x, y, z) elements.
<table border>
<tr class=ctor><td><code>new Vec3(<em>x=0, y=0, z=0</em>)</code></td>
  <td>Creates a vector (<code>x</code>, <code>y</code>, <code>z</code>).</td></tr>
<tr><td><code>.x</code></td>
  <td>The x value.</td></tr>
<tr><td><code>.y</code></td>
  <td>The y value.</td></tr>
<tr><td><code>.z</code></td>
  <td>The z value.</td></tr>
<tr><td><code>.copy()</code></td>
  <td>Duplicates the vector.</td></tr>
<tr><td><code>.equals(p)</code></td>
  <td><code>true</code> if <code>p</code> is identical.</td></tr>
<tr><td><code>.isZero()</code></td>
  <td><code>true</code> if the vector is zero length.</td></tr>
<tr><td><code>.len2()</code></td>
  <td>The length<sup>2</sup> of the vector.</td></tr>
<tr><td><code>.len()</code></td>
  <td>The length of the vector.</td></tr>
<tr><td><code>.sign()</code></td>
  <td>(<code>sign(x)</code>, <code>sign(y)</code>, <code>sign(z)</code>).</td></tr>
<tr><td><code>.add(v)</code></td>
  <td>(<code>this</code> + <code>v</code>).</td></tr>
<tr><td><code>.sub(v)</code></td>
  <td>(<code>this</code> - <code>v</code>).</td></tr>
<tr><td><code>.scale(n)</code></td>
  <td>(<code>n</code> &sdot; <code>this</code>).</td></tr>
<tr><td><code>.distance(p)</code></td>
  <td>|<code>this</code> - <code>p</code>|.</td></tr>
<tr><td><code>.clamp(bounds)</code></td>
  <td>(<code>clamp(x)</code>, <code>clamp(y)</code>, <code>clamp(z)</code>).</td></tr>
<tr><td><code>.move(dx, dy, dz)</code></td>
  <td>(<code>x+dx</code>, <code>y+dy</code>, <code>z+dz</code>).</td></tr>
<tr><td><code>.interpolate(p, t)</code></td>
  <td>(<code>this*(1-t) + p*t)</code>.</td></tr>
</table>

<a name="Collider"><h3>Collider (<code>geom.ts</code>)</h3></a>
<p>
A <code>Collider</code> is an abstract geometric object 
that can be used for hit detection.
<table border>
<tr><td><code>.copy()</code></td>
  <td>Duplicates the collider.</td></tr>
<tr><td><code>.move(dx, dy)</code></td>
  <td>Creates a collider moved by (<code>dx</code>, <code>dy</code>).</td></tr>
<tr><td><code>.add(v)</code></td>
  <td>Creates a collider moved by <code>v</code>.</td></tr>
<tr><td><code>.sub(v)</code></td>
  <td>Creates a collider moved by <code>-v</code>.</td></tr>
<tr><td><code>.equals(collider)</code></td>
  <td><code>true</code> if <code>collider</code> is identical.</td></tr>
<tr><td><code>.overlaps(collider)</code></td>
  <td><code>true</code> if this collider overlaps <code>collider</code>.</td></tr>
<tr><td><code>.contact(v, collider)</code></td>
  <td>Trims a vector so that <code>collider</code> doesn't collide with this.</td></tr>
<tr><td><code>.getAABB()</code></td>
  <td>Returns the AABB of the collider.</td></tr>
</table>

<a name="Shape"><h3>Shape : <a href="#Collider">Collider</a> (<code>geom.ts</code>)</h3></a>
<p>
A <code>Shape</code> is an abstract class that represents an enclosed shape.
<table border>
<tr><td><code>.isZero()</code></td>
  <td><code>true</code> if the shape is empty.</td></tr>
<tr><td><code>.containsPt(p)</code></td>
  <td><code>true</code> if the shape contains <code>p</code>.</td></tr>
<tr><td><code>.rndPt()</code></td>
  <td>Returns a random point within the shape.</td></tr>
<tr><td><code>.rndPtEdge()</code></td>
  <td>Returns a random point on the edge.</td></tr>
</table>

<a name="AALine"><h3>AALine : <a href="#Collider">Collider</a> (<code>geom.ts</code>)</h3></a>
<p>
A <code>AALine</code> represents an axis-aligned (either horizontal or
parpendicular) line.
<table border>
<tr class=ctor><td><code>new AALine(<em>x0, y0, x1, y1</em>)</code></td>
  <td>Creates an AALine.</td></tr>
<tr><td><code>.x0</code></td>
  <td>The x0 value.</td></tr>
<tr><td><code>.y0</code></td>
  <td>The y0 value.</td></tr>
<tr><td><code>.x1</code></td>
  <td>The x1 value.</td></tr>
<tr><td><code>.y1</code></td>
  <td>The y1 value.</td></tr>
</table>

<a name="Rect"><h3>Rect : <a href="#Shape">Shape</a> (<code>geom.ts</code>)</h3></a>
<p>
A <code>Rect</code> object is a 2D rectangle that 
has its position (x, y) and size (width, height).
<table border>
<tr class=ctor><td><code>new Rect(<em>x=0, y=0, w=0, h=0</em>)</code></td>
  <td>Creates a rectangle (<code>x</code>, <code>y</code>, <code>w</code>, <code>h</code>).</td></tr>
<tr><td><code>.x</code></td>
  <td>The x value of the top-left corner.</td></tr>
<tr><td><code>.y</code></td>
  <td>The y value of the top-left corner.</td></tr>
<tr><td><code>.width</code></td>
  <td>The width of the rectangle.</td></tr>
<tr><td><code>.height</code></td>
  <td>The height of the rectangle.</td></tr>
<tr><td><code>.right()</code></td>
  <td>The right edge of the rectangle.</td></tr>
<tr><td><code>.bottom()</code></td>
  <td>The bottom edge of the rectangle.</td></tr>
<tr><td><code>.centerx()</code></td>
  <td>The center-x of the rectangle.</td></tr>
<tr><td><code>.centery()</code></td>
  <td>The center-y of the rectangle.</td></tr>
<tr><td><code>.center()</code></td>
  <td>The center of the rectangle.</td></tr>
<tr><td><code>.inflate(dw, dh)</code></td>
  <td>Creates a inflated/deflated rectangle by (<code>dw</code>, <code>dh</code>):
    <div style="margin-left:1em;">
      <svg xmlns="http://www.w3.org/2000/svg" 
	   xmlns:xlink="http://www.w3.org/1999/xlink"
	   version="1.1" width="100" height="48">
	<g transform="translate(1.5,1.5)">
	  <g fill="none" stroke="black" stroke-width="1">
	    <rect x="20" y="12" width="50" height="20" />
	    <rect x="0" y="0" width="90" height="44" />
	    <line x1="0" y1="22" x2="20" y2="22" />
	    <line x1="45" y1="0" x2="45" y2="12" />
	    <circle cx="45" cy="22" r="2" />
	  </g>
	  <g style="font-size: 75%;">
	    <text x="1" y="20">dw</text>
	    <text x="46" y="10">dh</text>
	  </g>
	</g>
      </svg>
    </div>
  </td></tr>
<tr><td><code>.anchor(<em>[vx, [vy]]</em>)</code></td>
  <td>The anchor point of the rectangle:
    <div style="margin-left:1em;">
      <svg xmlns="http://www.w3.org/2000/svg" 
	   xmlns:xlink="http://www.w3.org/1999/xlink"
	   version="1.1" width="125" height="49">
	<g transform="translate(2.5,2.5)">
	  <g fill="none" stroke="black" stroke-width="1">
	    <rect x="0" y="0" width="120" height="44" />
	    <circle cx="0" cy="0" r="2" />
	    <circle cx="60" cy="0" r="2" />
	    <circle cx="120" cy="0" r="2" />
	    <circle cx="0" cy="22" r="2" />
	    <circle cx="60" cy="22" r="2" />
	    <circle cx="120" cy="22" r="2" />
	    <circle cx="0" cy="44" r="2" />
	    <circle cx="60" cy="44" r="2" />
	    <circle cx="120" cy="44" r="2" />
	  </g>
	  <g style="font-size: 75%;">
	    <text x="0" y="11" text-anchor="begin">(-1,-1)</text>
	    <text x="60" y="11" text-anchor="middle">(0,-1)</text>
	    <text x="120" y="11" text-anchor="end">(+1,-1)</text>
	    <text x="0" y="26" text-anchor="begin">(-1,0)</text>
	    <text x="120" y="26" text-anchor="end">(+1,0)</text>
	    <text x="0" y="41" text-anchor="begin">(-1,+1)</text>
	    <text x="60" y="41" text-anchor="middle">(0,+1)</text>
	    <text x="120" y="41" text-anchor="end">(+1,+1)</text>
	  </g>
	</g>
      </svg>
    </div>
  </td></tr>
<tr><td><code>.expand(dw, dh, <em>[vx, [vy]]</em>)</code></td>
  <td>Creates an expanded rectangle by (<code>dw</code>, <code>dh</code>).
    <div style="margin-left:1em;">
      <svg xmlns="http://www.w3.org/2000/svg" 
	   xmlns:xlink="http://www.w3.org/1999/xlink"
	   version="1.1" width="200" height="90">
	<marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
	  <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
	</marker>
	<g transform="translate(36.5,4.5)">
	  <g fill="none" stroke="black" stroke-width="1">
	    <rect x="30" y="30" width="40" height="20" />
	    <rect x="0" y="10" width="100" height="60" />
	    <line x1="0" y1="29" x2="100" y2="29" />
	    <line x1="0" y1="51" x2="100" y2="51" />
	    <line x1="29" y1="10" x2="29" y2="70" />
	    <line x1="71" y1="10" x2="71" y2="70" />
	    <g marker-end="url(#arrow)" stroke-width="2">
	      <line x1="25" y1="25" x2="5" y2="15" />
	      <line x1="75" y1="25" x2="95" y2="15" />
	      <line x1="25" y1="55" x2="5" y2="65" />
	      <line x1="75" y1="55" x2="95" y2="65" />
	      <line x1="25" y1="40" x2="5" y2="40" />
	      <line x1="75" y1="40" x2="95" y2="40" />
	      <line x1="50" y1="25" x2="50" y2="15" />
	      <line x1="50" y1="55" x2="50" y2="65" />
	    </g>
	  </g>
	  <g style="font-size: 75%;">
	    <text x="0" y="8" text-anchor="end">(-1,-1)</text>
	    <text x="50" y="8" text-anchor="middle">(0,-1)</text>
	    <text x="100" y="8" text-anchor="begin">(+1,-1)</text>
	    <text x="0" y="45" text-anchor="end">(-1,0)</text>
	    <text x="100" y="45" text-anchor="begin">(+1,0)</text>
	    <text x="0" y="80" text-anchor="end">(-1,+1)</text>
	    <text x="50" y="80" text-anchor="middle">(0,+1)</text>
	    <text x="100" y="80" text-anchor="begin">(+1,+1)</text>
	  </g>
	</g>
      </svg>
    </div>
  </td></tr>
<tr><td><code>.resize(w, h, <em>[vx, [vy]]</em>)</code></td>
  <td>Creates a resized rectangle.
    <div style="margin-left:1em;">
      <svg xmlns="http://www.w3.org/2000/svg" 
	   xmlns:xlink="http://www.w3.org/1999/xlink"
	   version="1.1" width="200" height="90">
	<marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
	  <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
	</marker>
	<g transform="translate(36.5,4.5)">
	  <g fill="none" stroke="black" stroke-width="1">
	    <rect x="30" y="30" width="40" height="20" />
	    <rect x="0" y="10" width="100" height="60" />
	    <line x1="0" y1="29" x2="100" y2="29" />
	    <line x1="0" y1="51" x2="100" y2="51" />
	    <line x1="29" y1="10" x2="29" y2="70" />
	    <line x1="71" y1="10" x2="71" y2="70" />
	    <g marker-end="url(#arrow)" stroke-width="2">
	      <line x1="25" y1="25" x2="5" y2="15" />
	      <line x1="75" y1="25" x2="95" y2="15" />
	      <line x1="25" y1="55" x2="5" y2="65" />
	      <line x1="75" y1="55" x2="95" y2="65" />
	      <line x1="25" y1="40" x2="5" y2="40" />
	      <line x1="75" y1="40" x2="95" y2="40" />
	      <line x1="50" y1="25" x2="50" y2="15" />
	      <line x1="50" y1="55" x2="50" y2="65" />
	    </g>
	  </g>
	  <g style="font-size: 75%;">
	    <text x="0" y="8" text-anchor="end">(-1,-1)</text>
	    <text x="50" y="8" text-anchor="middle">(0,-1)</text>
	    <text x="100" y="8" text-anchor="begin">(+1,-1)</text>
	    <text x="0" y="45" text-anchor="end">(-1,0)</text>
	    <text x="100" y="45" text-anchor="begin">(+1,0)</text>
	    <text x="0" y="80" text-anchor="end">(-1,+1)</text>
	    <text x="50" y="80" text-anchor="middle">(0,+1)</text>
	    <text x="100" y="80" text-anchor="begin">(+1,+1)</text>
	  </g>
	</g>
      </svg>
    </div>
  </td></tr>
<tr><td><code>.xdistance(rect)</code></td>
  <td>The x-distance to <code>rect</code>.</td></tr>
<tr><td><code>.ydistance(rect)</code></td>
  <td>The y-distance to <code>rect</code>.</td></tr>
<tr><td><code>.containsRect(rect)</code></td>
  <td><code>true</code> if the rectangle contains <code>rect</code>.</td></tr>
<tr><td><code>.overlapsRect(rect)</code></td>
  <td><code>true</code> if the rectangle overlaps <code>rect</code>.</td></tr>
<tr><td><code>.overlapsCircle(circle)</code></td>
  <td><code>true</code> if the rectangle overlaps <code>circle</code>.</td></tr>
<tr><td><code>.union(rect)</code></td>
  <td>Combines two rectangles (union).</td></tr>
<tr><td><code>.intersection(rect)</code></td>
  <td>Combines two rectangles (intersection).</td></tr>
<tr><td><code>.clamp(bounds)</code></td>
  <td>Moves the rectangle so that it fits <code>bounds</code>.</td></tr>
<tr><td><code>.modpt(p)</code></td>
  <td>Creates a modulo point with the rectangle.</td></tr>
<tr><td><code>.contactRect(v, rect)</code></td>
  <td>Trims a vector so that <code>rect</code> doesn't collide with this.</td></tr>
<tr><td><code>.boundRect(v, rect)</code></td>
  <td>Trims a vector so that <code>rect</code> is restricted inside this.</td></tr>
</table>

<a name="Circle"><h3>Circle : <a href="#Shape">Shape</a>, <a href="#Collider">Collider</a> (<code>geom.ts</code>)</h3></a>
<p>
A <code>Circle</code> represents a circle that has its center and radius.
<table border>
<tr class=ctor><td><code>new Circle(<em>center, [radius]</em>)</code></td>
  <td>Creates a circle.</td></tr>
<tr><td><code>.center</code></td>
  <td>The center of the circle.</td></tr>
<tr><td><code>.radius</code></td>
  <td>The radius of the circle.</td></tr>
<tr><td><code>.inflate(dr)</code></td>
  <td>Creates a inflated/deflated circle by <code>dr</code>.</tr></tr>
<tr><td><code>.resize(radius)</code></td>
  <td>Creates a resized circle.</tr></tr>
<tr><td><code>.distance(p)</code></td>
  <td>The distance to point <code>p</code>.</td></tr>
<tr><td><code>.containsCircle(circle)</code></td>
  <td><code>true</code> if the circle contains another <code>circle</code>.</td></tr>
<tr><td><code>.overlapsCircle(circle)</code></td>
  <td><code>true</code> if the circle overlaps another <code>circle</code>.</td></tr>
<tr><td><code>.overlapsRect(rect)</code></td>
  <td><code>true</code> if the circle overlaps <code>rect</code>.</td></tr>
<tr><td><code>.clamp(bounds)</code></td>
  <td>Moves the circle so that it fits <code>bounds</code>.</td></tr>
<tr><td><code>.contactCircle(v, circle)</code></td>
  <td>Trims a vector so that <code>circle</code> doesn't collide with this.</td></tr>
</table>

<a name="Box"><h3>Box (<code>geom.ts</code>)</h3></a>
<p>
A <code>Box</code> is a 3D cuboid that has its position and size
both as <code>Vec3</code>.
<table border>
<tr class=ctor><td><code>new Box(<em>origin, [size]</em>)</code></td>
  <td>Creates a box (<code>origin</code>, <code>size</code>).</td></tr>
<tr><td><code>.origin</code></td>
  <td>The origin of the box.</td></tr>
<tr><td><code>.size</code></td>
  <td>The size of the box.</td></tr>
<tr><td><code>.copy()</code></td>
  <td>Duplicates the box.</td></tr>
<tr><td><code>.equals(box)</code></td>
  <td><code>true</code> if <code>box</code> is identical.</td></tr>
<tr><td><code>.isZero()</code></td>
  <td><code>true</code> if the box is empty.</td></tr>
<tr><td><code>.center()</code></td>
  <td>The center of the box.</td></tr>
<tr><td><code>.anchor(<em>[vx, [vy, [vz]]]</em>)</code></td>
  <td>The anchor point of the box.</td></tr>
<tr><td><code>.move(dx, dy, dz)</code></td>
  <td>Creates a box moved by (<code>dx</code>, <code>dy</code>, <code>dz</code>).</td></tr>
<tr><td><code>.add(v)</code></td>
  <td>Creates a box moved by <code>v</code>.</td></tr>
<tr><td><code>.sub(v)</code></td>
  <td>Creates a box moved by <code>-v</code>.</td></tr>
<tr><td><code>.inflate(dx, dy, dz)</code></td>
  <td>Creates a inflated/deflated box by (<code>dx</code>, <code>dy</code>, <code>dz</code>).</td></tr>
<tr><td><code>.xdistance(box)</code></td>
  <td>The x-distance to <code>box</code>.</td></tr>
<tr><td><code>.ydistance(box)</code></td>
  <td>The y-distance to <code>box</code>.</td></tr>
<tr><td><code>.union(box)</code></td>
  <td>Combines two boxes (union).</td></tr>
<tr><td><code>.intersection(box)</code></td>
  <td>Combines two boxes (intersection).</td></tr>
<tr><td><code>.clamp(bounds)</code></td>
  <td>Moves the box so that it fits <code>bounds</code>.</td></tr>
<tr><td><code>.rndpt()</code></td>
  <td>Creates a random point within the box.</td></tr>
<tr><td><code>.zdistance(box)</code></td>
  <td>The z-distance to <code>box</code>.</td></tr>
<tr><td><code>.containsPt(p)</code></td>
  <td><code>true</code> if the box contains <code>p</code>.</td></tr>
<tr><td><code>.overlapsBox(box)</code></td>
  <td><code>true</code> if the box overlaps <code>box</code>.</td></tr>
<tr><td><code>.contactBox(v, box)</code></td>
  <td>Trims a vector so that <code>box</code> doesn't collide with this.</td></tr>
<tr><td><code>.union(box)</code></td>
  <td>Combines two boxes (union).</td></tr>
<tr><td><code>.intersection(box)</code></td>
  <td>Combines two boxses (intersection).</td></tr>
<tr><td><code>.clamp(bounds)</code></td>
  <td>Moves the box so that it fits <code>bounds</code>.</td></tr>
<tr><td><code>.rndpt()</code></td>
  <td>Creates a random point within the box.</td></tr>
</table>

<a name="TileMap"><h3>TileMap (<code>tilemap.ts</code>)</h3></a>
<p>
A <code>TileMap</code> represents a two-dimensional array that holds map tiles.
<table border>
<tr class=ctor><td><code>new TileMap(tilesize, map)</code></td>
  <td>Creates a new tilemap for a given array.</td></tr>
<tr><td><code>.tilesize</code></td>
  <td>The tile size.</td></tr>
<tr><td><code>.map</code></td>
  <td>Int32Array[] for the map data.</td></tr>
<tr><td><code>.width</code></td>
  <td>The number of tiles that fit horizontally in the map.</td></tr>
<tr><td><code>.height</code></td>
  <td>The number of tiles that fit vertically in the map.</td></tr>
<tr><td><code>.bounds</code></td>
  <td>The bounds of the map in the actual size.</td></tr>
<tr><td><code>.isObstacle</code></td>
  <td>A function that returns <code>true</code> for obstacle tiles.</td></tr>
<tr><td><code>.isGrabbable</code></td>
  <td>A function that returns <code>true</code> for grabbable tiles (e.g. ladders).</td></tr>
<tr><td><code>.isStoppable</code></td>
  <td>A function that returns <code>true</code> for stoppable tiles.</td></tr>
<tr><td><code>.get(x, y)</code></td>
  <td>Gets a tile at a specific position.</td></tr>
<tr><td><code>.set(x, y, c)</code></td>
  <td>Sets a tile at a specific position. (Clears the RangeMap cache.)</td></tr>
<tr><td><code>.fill(c, <em>[rect]</em>)</code></td>
  <td>Fills tiles in a given area.</td></tr>
<tr><td><code>.copy()</code></td>
  <td>Copies the tilemap.</td></tr>
<tr><td><code>.coord2map(rect)</code></td>
  <td>Converts an actual Rect/Vec2 to the tile cells.</td></tr>
<tr><td><code>.map2coord(rect)</code></td>
  <td>Converts a Rect/Vec2 for tile cells to the actual size.</td></tr>
<tr><td><code>.apply(f, <em>[rect]</em>)</code></td>
  <td>Applies a function to tiles.</td></tr>
<tr><td><code>.shift(vx, vy, <em>[rect]</em>)</code></td>
  <td>Shift the contents of cells in the given area.</td></tr>
<tr><td><code>.findTile(f, rect)</code></td>
  <td>Returns the position of the first tile in the given area.</td></tr>
<tr><td><code>.findTileByCoord(f, rect)</code></td>
  <td>Returns the position of the first tile in the given area.</td></tr>
<tr><td><code>.getTileRects(f, rect)</code></td>
  <td>Returns a list of actual rectangles for tiles.</td></tr>
<tr><td><code>.getRangeMap(key, f)</code></td>
  <td>Creates a <code>RangeMap</code> object for this tilemap.</td></tr>
<tr><td><code>.renderFromBottomLeft(<br>&nbsp; ctx, bx, by,<br>&nbsp; tileset, ft,<br>&nbsp; <em>[x0, y0, w, h]</em>)</code></td>
  <td>Renders the tiles from bottom left for a given tile set.</td></tr>
<tr><td><code>.renderFromTopRight(<br>&nbsp; ctx, bx, by,<br>&nbsp; tileset, ft,<br>&nbsp; <em>[x0, y0, w, h]</em>)</code></td>
  <td>Renders the tiles from top right for a given tile set.</td></tr>
<tr><td><code>.renderWindowFromBottomLeft(<br>&nbsp; ctx, bx, by,<br>&nbsp; window, tileset, ft)</code></td>
  <td>Renders the tiles from bottom left within a window.</td></tr>
<tr><td><code>.renderWindowFromTopRight(<br>&nbsp; ctx, bx, by,<br>&nbsp; window, tileset, ft)</code></td>
  <td>Renders the tiles from top right within a window.</td></tr>
</table>

<a name="RangeMap"><h3>RangeMap (<code>tilemap.ts</code>)</h3></a>
<p>
A <code>RangeMap</code> is a partial copy of <code>TileMap</code> 
that allows range queries for specific tiles.
<table border>
<tr class=ctor><td><code>new RangeMap(tilemap, f)</code></td>
  <td>Creates a new rangemap for certain tiles in a tilemap.</td></tr>
<tr><td><code>.width</code></td>
  <td>The number of tiles that fit horizontally in the map.</td></tr>
<tr><td><code>.height</code></td>
  <td>The number of tiles that fit vertically in the map.</td></tr>
<tr><td><code>.get(x0, y0, x1, y1)</code></td>
  <td>Returns the number of specific tiles within the given area.</td></tr>
<tr><td><code>.exists(rect)</code></td>
  <td><code>true</code> if a specific tile exists within the given area.</td></tr>
</table>

<a name="ImageSource"><h3>ImageSource (<code>sprite.ts</code>)</h3></a>
<p>
An <code>ImageSource</code> is a portion of a <code>&lt;img&gt;</code> 
that is used for rendering Sprites.
<table border>
<tr class=ctor><td><code>new HTMLImageSource(image, srcRect, dstRect)</code></td>
  <td>Creates a <code>ImageSource</code> from <code>&lt;img&gt;</code>.</td></tr>
<tr class=ctor><td><code>new FillImageSource(color, dstRect)</code></td>
  <td>Creates a <code>ImageSource</code> with a solid color.</td></tr>
</table>

<a name="SpriteSheet"><h3>SpriteSheet (<code>sprite.ts</code>)</h3></a>
<p>
A set of <code>ImageSource</code> objects indexed by a number.
<table border>
<tr class=ctor><td><code>new ImageSpriteSheet(image, size, <em>[origin]</em>)</code></td>
  <td>Creates a <code>SpriteSheet</code> from <code>&lt;img&gt;</code>.</td></tr>
<tr class=ctor><td><code>new SimpleSpriteSheet(imgsrcs)</code></td>
  <td>Creates a <code>SpriteSheet</code> with solid colors.</td></tr>
<tr><td><code>.get(i, <em>[j, [w, [h, [origin]]]]</em>)</code></td>
  <td>Returns the <code>i,j</code>-th <code>ImageSource</code>.</td></tr>
</table>

<a name="Sprite"><h3>Sprite (<code>sprite.ts</code>)</h3></a>
<p>
A <code>Sprite</code> represents something that's shown on the screen.
<table border>
<tr class=ctor><td><code>new Sprite(<em>[imgsrc]</em>)</code></td>
  <td>Creates a new sprite.</td></tr>
<tr><td><code>.imgsrc</code></td>
  <td>A <code>ImageSource</code> for the sprite's content.</td></tr>
<tr><td><code>.visible</code></td>
  <td><code>true</code> if the sprite is visible.</td></tr>
<tr><td><code>.zOrder</code></td>
  <td>The order that the sprite is drawn to the screen.</td></tr>
<tr><td><code>.scale</code></td>
  <td>A vector for the polarity of the sprite image.</td></tr>
<tr><td><code>.getBounds([pos])</code></td>
  <td>Returns the bounds for the given <code>pos</code>.</td></tr>
<tr class=overridable><td><code>.render(ctx, bx, by)</code></td>
  <td>Draws the sprite at the location (<code>bx</code>, <code>by</code>).</td></tr>
</table>

<a name="basic-classes"><h2>Basic Classes</h2></a>

<a name="Task"><h3>Task (<code>entity.ts</code>)</h3></a>
<p>
A <code>Task</code> is a process that belongs to a <code>Layer</code>
and its method is executed periodically.
<table border>
<tr class=ctor><td><code>new Task()</code></td>
  <td>Creates a new task.</td></tr>
<tr><td><code>.alive</code></td>
  <td><code>true</code> if the task is running.</td></tr>
<tr><td><code>.layer</code></td>
  <td>The <code>Layer</code> that the task belongs to.</td></tr>
<tr><td><code>.lifetime</code></td>
  <td>The duration that the task can run.</td></tr>
<tr><td><code>.started</code></td>
  <td>The time the task started.</td></tr>
<tr><td><code>.stopped</code></td>
  <td>A <code>Signal</code> that is signaled when the task stops.</td></tr>
<tr><td><code>.stop()</code></td>
  <td>Terminates the task.</td></tr>
<tr><td><code>.getTime()</code></td>
  <td>The elapsed time since the task has started (in seconds).</td></tr>
<tr class=overridable><td><code>.update()</code></td>
  <td>Updates for the current frame.</td></tr>
</table>

<a name="Entity"><h3>Entity : <a href="#Task">Task</a> (<code>entity.ts</code>)</h3></a>
<p>
An <code>Entity</code> is a physical object that's visible and has a physical boundary.
<table border>
<tr class=ctor><td><code>new Entity(pos)</code></td>
  <td>Creates a new entity.</td></tr>
<tr><td><code>.sprite</code></td>
  <td>A <code>Sprite</code> that belongs to this entity.</td></tr>
<tr><td><code>.collider</code></td>
  <td>A <code>Rect</code>/<code>Circle</code> for the entity's collider.</td></tr>
<tr><td><code>.getCollider([pos])</code></td>
  <td>Returns the collider for the given <code>pos</code>.</td></tr>
<tr><td><code>.canMove(v)</code></td>
  <td><code>true</code> if the entity is movable toward <code>v</code>.</td></tr>
<tr><td><code>.getMove(v)</code></td>
  <td>Trims the vector <code>v</code> so that it doesn't collide.</td></tr>
<tr><td><code>.movePos(v)</code></td>
  <td>Moves the entity by <code>v</code>.</td></tr>
<tr><td><code>.moveIfPossible(v, <em>[context]</em>)</code></td>
  <td>Moves the entity by <code>v</code> without colliding obstacles.</td></tr>
<tr class=overridable><td><code>.getObstaclesFor(range, context)</code></td>
  <td>Returns a list of <code>Shape</code>s within <code>range</code>.</td></tr>
<tr class=overridable><td><code>.getFencesFor(range, context)</code></td>
  <td>Returns a list of bounding rectangles that limits the entity within.</td></tr>
<tr class=overridable><td><code>.collidedWith(entity)</code></td>
  <td>Invoked when the entity collides another entity.</td></tr>
</table>

<a name="Layer"><h3>Layer (<code>layer.ts</code>)</h3></a>
<p>
A <code>Layer</code> contains a set of objects that can be rendered 
at once and interact each other.
<table border>
<tr class=ctor><td><code>new Layer()</code></td>
  <td>Creates a new layer.</td></tr>
<tr><td><code>.time</code></td>
  <td>The current time of the layer (in seconds).</td></tr>
<tr><td><code>.tasks</code></td>
  <td>A list of <code>Task</code>s that belong to the layer.</td></tr>
<tr><td><code>.sprites</code></td>
  <td>A list of <code>Sprite</code>s that belong to the layer.</td></tr>
<tr><td><code>.entities</code></td>
  <td>A list of <code>Entity</code>s that belong to the layer.</td></tr>
<tr><td><code>.addTask(task)</code></td>
  <td>Adds a <code>Task</code> to the list.</td></tr>
<tr><td><code>.addSprite(sprite)</code></td>
  <td>Adds a <code>Sprite</code> to the list.</td></tr>
<tr><td><code>.removeSprite(sprite)</code></td>
  <td>Removes a <code>Sprite</code> from the list.</td></tr>
<tr><td><code>.addEntity(entity)</code></td>
  <td>Adds an <code>Entity</code> to the list.</td></tr>
<tr><td><code>.removeEntity(sprite)</code></td>
  <td>Removes an <code>Entity</code> from the list.</td></tr>
<tr><td><code>.moveAll(v)</code></td>
  <td>Moves all the sprites by <code>v</code>.</td></tr>
<tr><td><code>.findEntities(f, <em>[entities]</em>)</code></td>
  <td>Returns a list of entities specified by function <code>f</code>.</td></tr>
<tr><td><code>.findSpriteAt(p)</code></td>
  <td>Returns a Sprite that is located at <code>p</code>.</td></tr>
<tr><td><code>.onMouseDown(p, button)</code></td>
  <td>Invoked when a mouse button is pressed.
<tr><td><code>.onMouseUp(p, button)</code></td>
  <td>Invoked when a mouse button is released.
<tr><td><code>.onMouseMove(p)</code></td>
  <td>Invoked when a mouse pointer is moved.
<tr class=overridable><td><code>.init()</code></td>
  <td>Invoked when the layer is initialized.</td></tr>
<tr class=overridable><td><code>.tick(t)</code></td>
  <td>Invoked for every frame.</td></tr>
<tr class=overridable><td><code>.render(ctx, bx, by)</code></td>
  <td>Draws all the sprites at the location (<code>bx</code>, <code>by</code>).</td></tr>
</table>

<a name="Scene"><h3>Scene (<code>scene.ts</code>)</h3></a>
<p>
A <code>Scene</code> represents one state of a game that can have its own
event handling (such as title screen or cut scene).
<table border>
<tr class=ctor><td><code>new Scene()</code></td>
  <td>Creates a new scene.</td></tr>
<tr><td><code>.screen</code></td>
  <td>The canvas rectangle.</td></tr>
<tr><td><code>.changeScene(scene)</code></td>
  <td>Signals the <code>App</code> to switch to a scene.</td></tr>
<tr class=overridable><td><code>.init()</code></td>
  <td>Initializes the scene.</td></tr>
<tr class=overridable><td><code>.tick(t)</code></td>
  <td>Invoked for every frame.</td></tr>
<tr class=overridable><td><code>.render(ctx, bx, by)</code></td>
  <td>Draws the scene at the location (<code>bx</code>, <code>by</code>).</td></tr>
<tr class=overridable><td><code>.setDir(v)</code></td>
  <td>Invoked when a directional input is changed.</td></tr>
<tr class=overridable><td><code>.setAction(action)</code></td>
  <td>Invoked when the action key state is changed.</td></tr>
<tr class=overridable><td><code>.setCancel(cancel)</code></td>
  <td>Invoked when the cancel key state is changed.</td></tr>
<tr class=overridable><td><code>.onKeyDown(keyCode)</code></td>
  <td>Invoked when a key is pressed.</td></tr>
<tr class=overridable><td><code>.onKeyUp(keyCode)</code></td>
  <td>Invoked when a key is released.</td></tr>
<tr class=overridable><td><code>.onMouseDown(p, button)</code></td>
  <td>Invoked when a mouse button is pressed.</td></tr>
<tr class=overridable><td><code>.onMouseUp(p, button)</code></td>
  <td>Invoked when a mouse button is released.</td></tr>
<tr class=overridable><td><code>.onMouseMove(p)</code></td>
  <td>Invoked when a mouse pointer is moved.</td></tr>
</table>

<a name="App"><h3>App (<code>app.ts</code>)</h3></a>
<p>
An <code>App</code> holds all the shared resources and is
responsible for switching Scenes.
<table border>
<tr class=ctor><td><code>new App(size, framerate, elem)</code></td>
  <td>Creates a new app with given HTML5 resources.</td></tr>
<tr><td><code>.size</code></td>
  <td>The canvas size.</td></tr>
<tr><td><code>.framerate</code></td>
  <td>The framerate.</td></tr>
<tr><td><code>.canvas</code></td>
  <td>The <code>&lt;canvas&gt;</code> element.</td></tr>
<tr><td><code>.ctx</code></td>
  <td>The <code>CanvasRenderingContext2D</code> object.</td></tr>
<tr><td><code>.scene</code></td>
  <td>The current <code>Scene</code>.</td></tr>
<tr><td><code>.active</code></td>
  <td><code>true</code> if the game is running.</td></tr>
<tr><td><code>.keys[]</code></td>
  <td>The states of the current keys.</td></tr>
<tr><td><code>.keyDir</code></td>
  <td>The state of the current directional input.</td></tr>
<tr><td><code>.addElement(bounds)</code></td>
  <td>Adds a new <code>&lt;div&gt;</code> element to the canvas.</td></tr>
<tr><td><code>.removeElement(elem)</code></td>
  <td>Removes the element from the canvas.</td></tr>
<tr><td><code>.lockKeys()</code></td>
  <td>Blocks accidental keyboard input for one second.</td></tr>
<tr><td><code>.setMusic(music, <em>[start, [end]]</em>)</code></td>
  <td>Starts/Stops the music loop.</td></tr>
<tr><td><code>.init(scene)</code></td>
  <td>Initializes the game with the first <code>Scene</code>.</td></tr>
<tr><td><code>.post(msg)</code></td>
  <td>Queues a function that is to be executed at the end of the frame.</td></tr>
</table>


<a name="specialized-classes"><h2>Specialized Classes</h2></a>

<a name="TiledSprite"><h3>TiledSprite : <a href="#Sprite">Sprite</a> (<code>sprite.ts</code>)</h3></a>
<p>
A <code>Sprite</code> shows an image repeatedly within the bounds.
Suitable for backgrounds.
<table border>
<tr class=ctor><td><code>new TiledSprite(bounds)</code></td>
  <td>Creates a new sprite.</td></tr>
<tr class=inherited><td><code>.imgsrc</code></td>
  <td>A <code>ImageSource</code> for the sprite's content.</td></tr>
<tr><td><code>.offset</code></td>
  <td>The offset of the image (in <code>Vec2</code>).</td></tr>
</table>

<a name="StarSprite"><h3>StarSprite : <a href="#Sprite">Sprite</a> (<code>sprite.ts</code>)</h3></a>
<p>
A <code>Sprite</code> that shows multiple parallaxed stars. 
Suitable for space-y backgrounds.
<table border>
<tr class=ctor><td><code>new StarSprite(<br>&nbsp; bounds, nstars,<br>&nbsp; <em>[maxdepth]</em>)</code></td>
  <td>Creates a new sprite.</td></tr>
<tr class=inherited><td><code>.imgsrc</code></td>
  <td>A <code>ImageSource</code> for each star's content.</td></tr>
<tr><td><code>.bounds</code></td>
  <td>The bounds of all stars.</td></tr>
<tr><td><code>.velocity</code></td>
  <td>The velocity of the star movement.</td></tr>
<tr><td><code>.maxdepth</code></td>
  <td>The maximum depth of stars.</td></tr>
</table>

<a name="Projectile"><h3>Projectile : <a href="#Entity">Entity</a> (<code>entity.ts</code>)</h3></a>
<p>
A <code>Projectile</code> is an <code>Entity</code> that 
keeps moving towards a specific direction.
Suitable for bullets or obstacles.
<table border>
<tr class=ctor><td><code>new Projectile(pos)</code></td>
  <td>Creates a new projectile.</td></tr>
<tr class=inherited><td><code>.imgsrc</code></td>
  <td>A <code>ImageSource</code> for the entity's content.</td></tr>
<tr><td><code>.movement</code></td>
  <td>The velocity of the object.</td></tr>
<tr><td><code>.frame</code></td>
  <td>The rectangle where the object is kept alive within.</td></tr>
</table>

<a name="PhysicalEntity"><h3>PhysicalEntity : <a href="#Entity">Entity</a> (<code>entity.ts</code>)</h3></a>
<p>
An <code>Entity</code> that is affected by gravity.
Suitable for charcters or objects that can jump or fall.
<table border>
<tr class=ctor><td><code>new PhysicalEntity(pos)</code></td>
  <td>Creates a new entity.</td></tr>
<tr class=inherited><td><code>.alive</code></td>
  <td><code>true</code> if the entity is alive.</td></tr>
<tr class=inherited><td><code>.layer</code></td>
  <td>A <code>Layer</code> that the entity belongs to.</td></tr>
<tr class=inherited><td><code>.time</code></td>
  <td>The elapsed time since the entity started.</td></tr>
<tr class=inherited><td><code>.stopped</code></td>
  <td>A <code>Signal</code> that is signaled when the entity stops.</td></tr>
<tr class=inherited><td><code>.bounds</code></td>
  <td>A <code>Rect</code> for the entity's size and position.</td></tr>
<tr class=inherited><td><code>.imgsrc</code></td>
  <td>A <code>ImageSource</code> for the entity's content.</td></tr>
<tr class=inherited><td><code>.visible</code></td>
  <td><code>true</code> if the entity is visible.</td></tr>
<tr class=inherited><td><code>.zOrder</code></td>
  <td>The order that the entity is drawn to the screen.</td></tr>
<tr class=inherited><td><code>.scale</code></td>
  <td>A vector for the polarity of the entity image.</td></tr>
<tr><td><code>.velocity</code></td>
  <td>A vector for the current velocity.</td></tr>
<tr><td><code>.maxspeed</code></td>
  <td>A vector for the maximum speed (absolute values).</td></tr>
<tr><td><code>.jumpfunc</code></td>
  <td>A gravity function <code>(vy:number, t:number) =&gt; number</code></td></tr>
<tr class=inherited><td><code>.stop()</code></td>
  <td>Terminates the entity.</td></tr>
<tr class=inherited><td><code>.movePos(v)</code></td>
  <td>Moves the entity by <code>v</code>.</td></tr>
<tr class=inherited><td><code>.collider</code></td>
  <td>A <code>Rect</code>/<code>Circle</code> for the entity's collider.</td></tr>
<tr class=overridable><td><code>.update()</code></td>
  <td>Updates for the current frame.</td></tr>
<tr class=overridable><td><code>.render(ctx, bx, by)</code></td>
  <td>Draws the entity at the location (<code>bx</code>, <code>by</code>).</td></tr>
<tr class=overridable><td><code>.collidedWith(entity)</code></td>
  <td>Invoked when the entity collides another entity.</td></tr>
<tr class=inherited><td><code>.moveIfPossible(v, <em>[context]</em>)</code></td>
  <td>Moves the entity by <code>v</code> without colliding obstacles.</td></tr>
<tr class=inherited><td><code>.isMovable(v)</code></td>
  <td><code>true</code> if the entity is movable toward <code>v</code>.</td></tr>
<tr class=inherited><td><code>.getMove(v)</code></td>
  <td>Trims the vector <code>v</code> so that it doesn't collide.</td></tr>
<tr class=overridable><td><code>.getObstaclesFor(range, context)</code></td>
  <td>Returns a list of <code>Shape</code>s within <code>range</code>.</td></tr>
<tr class=overridable><td><code>.getFencesFor(range, context)</code></td>
  <td>Returns a list of bounding rectangles that limits the entity within.</td></tr>
<tr><td><code>.setJumpFunc(function)</code></td>
  <td>Sets the gravity function.</td></tr>
<tr><td><code>.setJump(jumpend)</code></td>
  <td>Starts a jump maneuver that ends at <code>t=jumpend</code>.</td></tr>
<tr class=overridable><td><code>.jump()</code></td>
  <td>Invoked when the entity starts jumping.</td></tr>
<tr><td><code>.fall()</code></td>
  <td>Invoked for every update.</td></tr>
<tr><td><code>.isLanded()</code></td>
  <td><code>true</code> if the entity is landed on a platform.</td></tr>
<tr class=overridable><td><code>.land()</code></td>
  <td>Invoked when the entity is landed on a platform.</td></tr>
<tr class=overridable><td><code>.isHolding()</code></td>
  <td><code>true</code> if the entity is in a state that stops falling.</td></tr>
</table>

<a name="PlatformerEntity"><h3>PlatformerEntity : <a href="#PhysicalEntity">PhysicalEntity</a> (<code>entity.ts</code>)</h3></a>
<p>
A <code>PhysicalEntity</code> that interacts with a <code>TileMap</code>.
Suitable for tile-based platformer games.
<table border>
<tr class=ctor><td><code>new PlatformerEntity(tilemap, pos)</code></td>
  <td>Creates a new entity.</td></tr>
<tr class=inherited><td><code>.alive</code></td>
  <td><code>true</code> if the entity is alive.</td></tr>
<tr class=inherited><td><code>.layer</code></td>
  <td>A <code>Layer</code> that the entity belongs to.</td></tr>
<tr class=inherited><td><code>.time</code></td>
  <td>The elapsed time since the entity started.</td></tr>
<tr class=inherited><td><code>.stopped</code></td>
  <td>A <code>Signal</code> that is signaled when the entity stops.</td></tr>
<tr class=inherited><td><code>.bounds</code></td>
  <td>A <code>Rect</code> for the entity's size and position.</td></tr>
<tr class=inherited><td><code>.imgsrc</code></td>
  <td>A <code>ImageSource</code> for the entity's content.</td></tr>
<tr class=inherited><td><code>.visible</code></td>
  <td><code>true</code> if the entity is visible.</td></tr>
<tr class=inherited><td><code>.zOrder</code></td>
  <td>The order that the entity is drawn to the screen.</td></tr>
<tr class=inherited><td><code>.scale</code></td>
  <td>A vector for the polarity of the entity image.</td></tr>
<tr class=inherited><td><code>.velocity</code></td>
  <td>A vector for the current velocity.</td></tr>
<tr class=inherited><td><code>.maxspeed</code></td>
  <td>A vector for the maximum speed (absolute values).</td></tr>
<tr class=inherited><td><code>.jumpfunc</code></td>
  <td>A gravity function <code>(vy:number, t:number) =&gt; number</code></td></tr>
<tr><td><code>.tilemap</code></td>
  <td>A <code>TileMap</code> that interacts with the entity.</td></tr>
<tr class=inherited><td><code>.stop()</code></td>
  <td>Terminates the entity.</td></tr>
<tr class=inherited><td><code>.movePos(v)</code></td>
  <td>Moves the entity by <code>v</code>.</td></tr>
<tr class=inherited><td><code>.collider</code></td>
  <td>A <code>Rect</code>/<code>Circle</code> for the entity's collider.</td></tr>
<tr class=overridable><td><code>.update()</code></td>
  <td>Updates for the current frame.</td></tr>
<tr class=overridable><td><code>.render(ctx, bx, by)</code></td>
  <td>Draws the entity at the location (<code>bx</code>, <code>by</code>).</td></tr>
<tr class=overridable><td><code>.collidedWith(entity)</code></td>
  <td>Invoked when the entity collides another entity.</td></tr>
<tr class=inherited><td><code>.moveIfPossible(v, <em>[context]</em>)</code></td>
  <td>Moves the entity by <code>v</code> without colliding obstacles.</td></tr>
<tr class=inherited><td><code>.isMovable(v)</code></td>
  <td><code>true</code> if the entity is movable toward <code>v</code>.</td></tr>
<tr class=inherited><td><code>.getMove(v)</code></td>
  <td>Trims the vector <code>v</code> so that it doesn't collide.</td></tr>
<tr class=overridable><td><code>.getFencesFor(range, context)</code></td>
  <td>Returns a list of bounding rectangles that limits the entity within.</td></tr>
<tr class=inherited><td><code>.setJumpFunc(function)</code></td>
  <td>Sets the gravity function.</td></tr>
<tr class=inherited><td><code>.setJump(jumpend)</code></td>
  <td>Starts a jump maneuver that ends at <code>t=jumpend</code>.</td></tr>
<tr class=overridable><td><code>.jump()</code></td>
  <td>Invoked when the entity starts jumping.</td></tr>
<tr class=inherited><td><code>.fall()</code></td>
  <td>Invoked for every update.</td></tr>
<tr class=inherited><td><code>.isLanded()</code></td>
  <td><code>true</code> if the entity is landed on a platform.</td></tr>
<tr class=overridable><td><code>.land()</code></td>
  <td>Invoked when the entity is landed on a platform.</td></tr>
</table>

<a name="ScrollLayer"><h3>ScrollLayer : <a href="#Layer">Layer</a> (<code>layer.ts</code>)</h3></a>
<p>
A <code>Layer</code> that can scroll the displayed area. 
Only shows the objects within the window.
<table border>
<tr class=ctor><td><code>new ScrollLayer(window)</code></td>
  <td>Creates a new layer.</td></tr>
<tr class=inherited><td><code>.tasks</code></td>
  <td>A list of <code>Task</code>s that belong to the layer.</td></tr>
<tr class=inherited><td><code>.sprites</code></td>
  <td>A list of <code>Sprite</code>s that belong to the layer.</td></tr>
<tr class=inherited><td><code>.entities</code></td>
  <td>A list of <code>Entity</code>s that belong to the layer.</td></tr>
<tr><td><code>.window</code></td>
  <td>A <code>Rect</code> that specifies the window.</td></tr>
<tr class=overridable><td><code>.init()</code></td>
  <td>Invoked when the layer is initialized.</td></tr>
<tr class=overridable><td><code>.tick(t)</code></td>
  <td>Invoked for every frame.</td></tr>
<tr class=inherited><td><code>.render(ctx, bx, by)</code></td>
  <td>Draws all the sprites at the location (<code>bx</code>, <code>by</code>).</td></tr>
<tr class=inherited><td><code>.moveAll(v)</code></td>
  <td>Moves all the sprites by <code>v</code>.</td></tr>
<tr><td><code>.moveCenter(v)</code></td>
  <td>Moves the window by <code>v</code>.</td></tr>
<tr><td><code>.setCenter(bounds, rect)</code></td>
  <td>Centers the window around <code>rect</code>.</td></tr>
<tr class=inherited><td><code>.addTask(task)</code></td>
  <td>Adds a <code>Task</code>/<code>Sprite</code>/<code>Entity</code> to the list.</td></tr>
<tr class=inherited><td><code>.findEntities(rect, <em>[entities, [f]]</em>)</code></td>
  <td>Returns a list of entities that overlap <code>rect</code>.</td></tr>
</table>

<a name="GameScene"><h3>GameScene : <a href="#Scene">Scene</a> (<code>scene.ts</code>)</h3></a>
<p>
A <code>Scene</code> that has one <code>Layer</code> with
a few convenient methods.
<table border>
<tr class=ctor><td><code>new GameScene(app)</code></td>
  <td>Creates a new scene.</td></tr>
<tr class=inherited><td><code>.app</code></td>
  <td>The <code>App</code> object that the scene belongs to.</td></tr>
<tr class=inherited><td><code>.screen</code></td>
  <td>The canvas rectangle.</td></tr>
<tr><td><code>.layer</code></td>
  <td>A <code>Layer</code> for this scene.</td></tr>
<tr><td><code>.entities</code></td>
  <td>An alias to <code>layer.entities</code>.</td></tr>
<tr><td><code>.addTask(task)</code></td>
  <td>Adds a <code>Task</code>/<code>Sprite</code>/<code>Entity</code> to the list.</td></tr>
<tr class=inherited><td><code>.changeScene(scene)</code></td>
  <td>Signals the <code>App</code> to switch to a scene.</td></tr>
<tr class=overridable><td><code>.init()</code></td>
  <td>Initializes the scene.</td></tr>
<tr class=overridable><td><code>.tick(t)</code></td>
  <td>Invoked for every frame.</td></tr>
<tr class=overridable><td><code>.render(ctx, bx, by)</code></td>
  <td>Draws the scene at the location (<code>bx</code>, <code>by</code>).</td></tr>
<tr class=overridable><td><code>.setDir(v)</code></td>
  <td>Invoked when a directional input is changed.</td></tr>
<tr class=overridable><td><code>.setAction(action)</code></td>
  <td>Invoked when the action key state is changed.</td></tr>
<tr class=overridable><td><code>.setCancel(cancel)</code></td>
  <td>Invoked when the cancel key state is changed.</td></tr>
<tr class=overridable><td><code>.keydown(keyCode)</code></td>
  <td>Invoked when a key is pressed.</td></tr>
<tr class=overridable><td><code>.keyup(keyCode)</code></td>
  <td>Invoked when a key is released.</td></tr>
<tr class=overridable><td><code>.mousedown(x, y, button)</code></td>
  <td>Invoked when a mouse button is pressed.</td></tr>
<tr class=overridable><td><code>.mouseup(x, y, button)</code></td>
  <td>Invoked when a mouse button is released.</td></tr>
<tr class=overridable><td><code>.mousemove(x, y)</code></td>
  <td>Invoked when a mouse pointer is moved.</td></tr>
</table>

<a name="HTMLScene"><h3>HTMLScene : <a href="#Scene">Scene</a> (<code>scene.ts</code>)</h3></a>
<p>
A <code>Scene</code> for a static HTML text. 
Suitable for game title or help screen, etc.
<table border>
<tr class=ctor><td><code>new HTMLScene(app, text)</code></td>
  <td>Creates a new HTML scene.</td></tr>
<tr><td><code>.text</code></td>
  <td>A string to display.</td></tr>
<tr class=inherited><td><code>.changeScene(scene)</code></td>
  <td>Signals the <code>App</code> to switch to a scene.</td></tr>
<tr class=overridable><td><code>.change()</code></td>
  <td>Invoked when there's a mouse or keyboard input.</td></tr>
</table>

<a name="text"><h2>Text Library</h2></a>
<a name="Font"><h3>Font (<code>text.ts</code>)</h3></a>
<p>
A <code>Font</code> represents a monospace bitmap font.
<table border>
<tr class=ctor><td><code>new Font(glyphs, <em>[color, [scale]]</em>)</code></td>
  <td>Creates a <code>Font</code> with a given <code>glyphs</code>.</td></tr>
<tr><td><code>.width</code></td>
  <td>The width of individual character.</td></tr>
<tr><td><code>.height</code></td>
  <td>The height of individual character.</td></tr>
<tr><td><code>.getSize(text)</code></td>
  <td>Computes the pixel size for a given text.</td></tr>
<tr><td><code>.renderString(ctx, text, x, y)</code></td>
  <td>Draws the text at a given location.</td></tr>
</table>

<a name="ShadowFont"><h3>ShadowFont : <a href="#Font">Font</a> (<code>text.ts</code>)</h3></a>
<p>
A <code>Font</code> with shadow.
<table border>
<tr class=ctor><td><code>new ShadowFont(glyphs,<br>&nbsp; <em>[color, [scale,<br>&nbsp; [shadowcolor,<br>&nbsp; [shadowdist]]]]</em>)</code></td>
  <td>Creates a <code>ShadowFont</code> with a given <code>glyphs</code>.</td></tr>
<tr class=inherited><td><code>.width</code></td>
  <td>The width of individual character.</td></tr>
<tr class=inherited><td><code>.height</code></td>
  <td>The height of individual character.</td></tr>
<tr class=inherited><td><code>.getSize(text)</code></td>
  <td>Computes the pixel size for a given text.</td></tr>
<tr class=inherited><td><code>.renderString(ctx, text, x, y)</code></td>
  <td>Draws the text at a given location.</td></tr>
<tr><td><code>.getSize2(text)</code></td>
  <td>Computes the pixel size for a given text (including the shadow).</td></tr>
</table>

<a name="TextBox"><h3>TextBox : <a href="#Sprite">Sprite</a> (<code>text.ts</code>)</h3></a>
<a name="DialogBox"><h3>DialogBox : <a href="#TextBox">TextBox</a> (<code>text.ts</code>)</h3></a>

<a name="animation"><h2>Animation Library</h2></a>

<a name="Queue"><h3>Queue : <a href="#Task">Task</a> (<code>animation.ts</code>)</h3></a>
<p>
A <code>Queue</code> is a list of <code>Task</code>s that are executed sequentially.
<table border>
<tr class=ctor><td><code>new Queue(tasks)</code></td>
  <td>Creates a new queue that runs multiple <code>Task</code>s sequentially.</td></tr>
<tr class=inherited><td><code>.alive</code></td>
  <td><code>true</code> if the queue is running.</td></tr>
<tr class=inherited><td><code>.layer</code></td>
  <td>The <code>Layer</code> that the queue belongs to.</td></tr>
<tr class=inherited><td><code>.time</code></td>
  <td>The elapsed time since the queue started.</td></tr>
<tr class=inherited><td><code>.stopped</code></td>
  <td>A <code>Signal</code> that is signaled when the queue finishes.</td></tr>
<tr><td><code>.tasks</code></td>
  <td>A list of <code>Task</code>s to be executed.</td></tr>
<tr><td><code>.stopWhenEmpty</code></td>
  <td>Set <code>true</code> to automatically kill the queue when there's no <code>Task</code>.</td></tr>
<tr><td><code>.getCurrent()</code></td>
  <td>Returns the current <code>Task</code> or <code>null</code>.</td></tr>
<tr><td><code>.add(task)</code></td>
  <td>Adds a <code>Task</code> to the queue.</td></tr>
<tr><td><code>.remove(task)</code></td>
  <td>Removes a <code>Task</code> from the queue.</td></tr>
<tr><td><code>.clear()</code></td>
  <td>Removes all the <code>Task</code>s from the queue.</td></tr>
</table>

<a name="pathfinding"><h2>Pathfinding Library</h2></a>

<a name="PlanActor"><h3>PlanActor (<code>planmap.ts</code>)</h3></a>
<a name="PlanAction"><h3>PlanAction (<code>planmap.ts</code>)</h3></a>
<a name="PlanProfile"><h3>PlanProfile (<code>planmap.ts</code>)</h3></a>
<a name="PlanMap"><h3>PlanMap (<code>planmap.ts</code>)</h3></a>
<a name="PlanActionRunner"><h3>PlanActionRunner (<code>planrunner.ts</code>)</h3></a>
<a name="PlanningEntity"><h3>PlanningEntity (<code>planrunner.ts</code>)</h3></a>

</div>
</div> <!-- main -->
