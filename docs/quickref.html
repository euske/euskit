<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<style>
h1 { border-bottom: 4px solid; margin: 0; }
h2 { color: white; background: #880000; border-bottom: 2px solid black; }
h3 { background: #ffccff; border-bottom: 1px solid; }
table { border-collapse: collapse; }
td { padding: 2px; }
a { font-weight: bold; }
u { font-weight: bold; }
body { margin: 0; padding: 0; }
.code { border: 1px solid; padding: 0.2em; background: #eeeeee; }
.ctor { background: #ccffcc; }
.inherited { background: #cccccc; }
.override { background: #ffffcc; }
.nav { position: fixed; top: 0; left: 0; width: 20%; }
.main { position: absolute; top: 0; left: 20%; width: 80%; }
.list { margin-top: 1em; }
.list > .head { font-weight: bold; background: #88ffff; }
.navhead { font-size: 150%; font-weight: bold; }
.legend { font-size: 80%; margin: 8px; }
</style>
<title>Euskit Quick Reference</title>
</head>
<body>

<div class=nav>
<div style="padding: 0.5em;">

<div class=navhead><a href="https://github.com/euske/euskit">Euskit</a></div>

<div class=list>

<div class=legend><b>Legend:</b>
<span class=ctor><code>ctor</code></span>,
<span class=inherited><code>inherited</code></span>,
<span class=override><code>override</code></span>
</div>

<div class=head>Functions:</div>
<a href="#main">Main</a>,
<a href="#misc">Misc.</a>,
<a href="#numeric">Numeric</a>,
<a href="#array">Array</a>,
<a href="#html5">HTML5</a>
</div>

<div class=list>
<div class=head>Utility Classes:</div>
<a href="#Signal">Signal</a>,
<a href="#Color">Color</a>,
<a href="#Vec2">Vec2</a>,
<a href="#Vec3">Vec3</a>,
<a href="#Collider">Collider</a>,
<a href="#Shape">Shape</a>,
<a href="#AALine">AALine</a>,
<a href="#Rect">Rect</a>,
<a href="#Circle">Circle</a>,
<a href="#AAPlane">AAPlane</a>,
<a href="#Box">Box</a>,
<a href="#TileMap">TileMap</a>,
<a href="#RangeMap">RangeMap</a>,
<a href="#SpriteSheet">SpriteSheet</a>,
<a href="#PhysicsConfig">PhysicsConfig</a>,
<a href="#TaskList">TaskList</a>,
<a href="#TaskQueue">TaskQueue</a>,
<a href="#EntityWorld">EntityWorld</a>,
<a href="#SpriteLayer">SpriteLayer</a>
</div>

<div class=list>
<div class=head>Basic Objects:</div>
<a href="#ImageSource">ImageSource</a>,
<a href="#Sprite">Sprite</a>
<a href="#Task">Task</a>,
<a href="#Widget">Widget</a>,
<a href="#Entity">Entity</a>,
<a href="#Layer">Layer</a>,
<a href="#Scene">Scene</a>,
<a href="#App">App</a>
</div>

<div class=list>
<div class=head>Specialized Objects:</div>
<a href="#Projectile">Projectile</a>,
<a href="#TiledSprite">TiledSprite</a>,
<a href="#FlowSprite">FlowSprite</a>,
<a href="#PhysicalEntity">PhysicalEntity</a>,
<a href="#PlatformerEntity">PlatformerEntity</a>,
<a href="#ScrollLayer">ScrollLayer</a>,
<a href="#GameScene">GameScene</a>,
<a href="#HTMLScene">HTMLScene</a>
</div>

<div class=list>
<div class=head>Text Library:</div>
<a href="#Font">Font</a>,
<a href="#ShadowFont">ShadowFont</a>,
<a href="#TextBox">TextBox</a>,
<a href="#DialogBox">DialogBox</a>
</div>

<div class=list>
<div class=head>Animation Library:</div>
<a href="#Queue">Queue</a>
</div>

<div class=list>
<div class=head>Pathfinding Library:</div>
<a href="#PlanActor">PlanActor</a>,
<a href="#PlanAction">PlanAction</a>,
<a href="#PlanProfile">PlanProfile</a>,
<a href="#PlanMap">PlanMap</a>,
<a href="#PlanActionRunner">PlanActionRunner</a>,
<a href="#PlanningEntity">PlanningEntity</a>
</div>

</div>
</div>

<div class=main>
<div style="padding: 0.5em;">

<h1>API Quick Reference</h1>

<a name="big-picture"><h2>Big Picture</h2></a>
<div style="position:relative; margin:0; padding:0; height:10em;">
<div style="position:absolute; margin:0; top:0; left:0;">
  <svg xmlns="http://www.w3.org/2000/svg" 
       xmlns:xlink="http://www.w3.org/1999/xlink"
       version="1.1" width="250" height="150">
    <g transform="translate(1.5,1.5)">
      <g fill="none" stroke="black" stroke-width="1">
	<line x1="140" y1="12" x2="55" y2="100" />
	<line x1="140" y1="12" x2="175" y2="100" />
	<ellipse cx="140" cy="12" rx="20" ry="12" fill="white" />
	<rect x="0" y="55" width="110" height="92" fill="white" />
	<rect x="120" y="55" width="110" height="92" fill="white" />
	<rect x="30" y="62" width="50" height="16" fill="white" />
	<rect x="18" y="84" width="80" height="40" fill="white" />
	<rect x="14" y="88" width="80" height="40" fill="white" />
	<rect x="10" y="92" width="80" height="40" fill="white" />
	<rect x="30" y="114" width="16" height="16" />
	<rect x="33" y="117" width="10" height="10" />
	<line x1="45" y1="106" x2="38" y2="122" />
      </g>
      <g style="font-size: 75%;">
	<text x="140" y="15" text-anchor="middle">App</text>
	<text x="165" y="15">Images, ...</text>
	<text x="55" y="52" text-anchor="middle">Scene</text>
	<text x="175" y="52" text-anchor="middle">Scene</text>
	<text x="240" y="100" text-anchor="begin">...</text>
	<text x="55" y="74" text-anchor="middle">Camera</text>
	<text x="45" y="106" text-anchor="begin">Sprite</text>
	<text x="48" y="126" text-anchor="begin">Entity</text>
	<text x="70" y="144" text-anchor="begin">Layer</text>
      </g>
    </g>
  </svg>
</div>
  <div style="position:absolute; left: 270px; top: 0px; margin:0; line-height: 120%;">
    <a href="#App"><code>App</code></a>: 
    Resource management (images and sounds) and event loop.<br>
    <a href="#Scene"><code>Scene</code></a>: 
    Game state management and event handling.<br>
    <a href="#Entity"><code>Entity</code></a>: 
    In-game character.<br>
    <a href="#Sprite"><code>Sprite</code></a>: 
    Graphical object to be shown.<br>
    <a href="#Layer"><code>Layer</code></a>: 
    Container where Sprites are placed in.<br>
    <a href="#Camera"><code>Camera</code></a>: 
    Stack of layers to be rendered.<br>
  </div>
</div>

<a name="functions"><h2>Functions</h2></a>

<a name="main"><h3>Main function (<code>main.ts</code>)</h3></a>
<table border>
<tr><td><code>APP</td>
  <td>Global <code>App</code> instance.</td></tr>
<tr><td><code>addInitHook(<u>() =&gt; {}</u>)</td>
  <td>Has a hook executed after the page is loaded.</td></tr>
<tr><td><code>main(<br>&nbsp; <u>ctor</u>, <u>width</u>=320, <u>height</u>=240,<br>&nbsp; <u>canvasId</u>='game', <u>framerate</u>=30)</code></td>
  <td>Specifies the canvas size and the initial constructor of a <code>Scene</code> object.
    (without arg)</td></tr>
</table>

<h4>How to Use</h4>
<blockquote><pre class=code>
&lt;script&gt;
  class Scene1 extends Scene { ... }
&lt;/script&gt;
&lt;body onload="main(Scene1, 'game', 320, 240, 30);"&gt;
&lt;div id="main" style="width:640px; height:480px"&gt;&lt;/div&gt;
</pre></blockquote>

<a name="misc"><h3>Misc. functions (<code>utils.ts</code>)</h3></a>
<table border>
<tr><td><code>log(<u>msg</u>, ...)</code></td>
  <td>Displays the messages to the console.</td></tr>
<tr><td><code>assert(<u>cond</u>, <u>msg</u>="assertion error")</code></td>
  <td>Throws an exception when the condition is not met.</td></tr>
<tr><td><code>applyMixins(<u>ctor</u>, <u>bases</u>)</code></td>
  <td>Configures a new class.</td></tr>
</table>

<a name="numeric"><h3>Numeric functions (<code>utils.ts</code>)</h3></a>
<table border>
<tr><td><code>fmod(<u>x</u>, <u>y</u>)</code></td>
  <td>Better <code>mod</code> function; i.e. <code>fmod(-3,2)=1</code>.</td></tr>
<tr><td><code>int(<u>x</u>)</code></td>
  <td>Equivalent to <code>Math.floor</code>.</td></tr>
<tr><td><code>upperbound(<u>x</u>, <u>y</u>)</code></td>
  <td>Limits a value to min(<code>x</code>, <code>y</code>).</td></tr>
<tr><td><code>lowerbound(<u>x</u>, <u>y</u>)</code></td>
  <td>Limits a value to max(<code>x</code>, <code>y</code>).</td></tr>
<tr><td><code>clamp(<u>v0</u>, <u>v</u>, <u>v1</u>)</code></td>
  <td>Limits a value within [<code>v0</code>, <code>v1</code>].</td></tr>
<tr><td><code>sign(<u>v</u>)</code></td>
  <td>Returns -1, 0 or +1 based on the sign of <code>v</code>.</td></tr>
<tr><td><code>phase(<u>t</u>, <u>interval</u>, <u>n</u>=2)</code></td>
  <td>Returns the phase for time <code>t</code>.</td></tr>
<tr><td><code>frnd(<u>a</u>, <u>b</u>=0)</code></td>
  <td>Generates a value [0,<code>a</code>) or [<code>a</code>,<code>b</code>)</td></tr>
<tr><td><code>rnd(<u>a</u>, <u>b</u>=0)</code></td>
  <td>Generates an integer value [0,<code>a</code>) or [<code>a</code>,<code>b</code>)</td></tr>
<tr><td><code>getTime()</code></td>
  <td>Returns the current time in seconds.</td></tr>
<tr><td><code>format(<u>v</u>, <u>n</u>=3, <u>c</u>=' ')</code></td>
  <td>Formats a number as a string.</td></tr>
</table>

<a name="array"><h3>Array functions (<code>utils.ts</code>)</h3></a>
<table border>
<tr><td><code>choice(<u>a</u>)</code></td>
  <td>Returns a random element of <code>a</code>.</td></tr>
<tr><td><code>removeElement(<u>a</u>, <u>obj</u>)</code></td>
  <td>Removes an element from <code>a</code>.</td></tr>
<tr><td><code>range(<u>n</u>)</code></td>
  <td>Returns an array filled with a sequence [0, <code>n</code>-1].</td></tr>
<tr><td><code>str2array(<u>img</u>)</code></td>
  <td>Converts a string to a number array.</td></tr>
<tr><td><code>makeMatrix(<u>rows</u>, <u>cols</u>, <u>value</u>=0)</code></td>
  <td>Creates a 2D matrix for a given size.</td></tr>
</table>

<a name="html5"><h3>HTML5 functions (<code>utils.ts</code>)</h3></a>
<table border>
<tr><td><code>removeChildren(<u>node</u>, <u>name</u>)</code></td>
  <td>Removes all child HTML nodes.</td></tr>
<tr><td><code>createCanvas(<u>width</u>, <u>height</u>)</code></td>
  <td>Creates a <code>&lt;canvas&gt;</code> element.</td></tr>
<tr><td><code>getEdgeyContext(<u>canvas</u>)</code></td>
  <td>Creates a <code>CanvasRenderingContext2D</code>.</td></tr>
<tr><td><code>image2array(<u>img</u>)</code></td>
  <td>Converts an image to an 2D array.</td></tr>
<tr><td><code>fillRect(<u>ctx</u>, <u>rect</u>)</code></td>
  <td>Fills a rectangle.</td></tr>
<tr><td><code>strokeRect(<u>ctx</u>, <u>rect</u>)</code></td>
  <td>Draws a rectangle.</td></tr>
<tr><td><code>ellipse(<u>ctx</u>, <u>cx</u>, <u>cy</u>, <u>rx</u>, <u>ry</u>)</code></td>
  <td>Draws an ellipse at (cx, cy).</td></tr>
<tr><td><code>drawImageScaled(<br>&nbsp; <u>ctx</u>, <u>imgsrc</u>,<br>&nbsp; <u>sx</u>, <u>sy</u>, <u>sw</u>, <u>sh</u>,<br>&nbsp; <u>dx</u>, <u>dy</u>, <u>dw</u>, <u>dh</u>)</code></td>
  <td>Draws a flipped image.</td></tr>
<tr><td><code>getKeySym(<u>keycode</u>)</code></td>
  <td>Returns the <code>KeySym</code> for <code>keyCode</code>.</td></tr>
</table>

<a name="utility-classes"><h2>Utility Classes</h2></a>

<a name="Signal"><h3>Signal (<code>utils.ts</code>)</h3></a>
<p>
A <code>Signal</code> represents an event that is attached to a 
certain object and other objects can get notified.
<table border>
<tr class=ctor><td><code>new Signal(<em>baseargs</em>, ...)</code></td>
  <td>New <code>Signal</code> object with given <code>baseargs</code>.</td></tr>
<tr><td><code>.receivers</code></td>
  <td>List of the receiver functions.</td></tr>
<tr><td><code>.subscribe(<u>receiver</u>)</code></td>
  <td>Adds <code>receiver</code> to the subscriber list.</td></tr>
<tr><td><code>.unsubscribe(<u>receiver</u>)</code></td>
  <td>Removes <code>receiver</code> from the subscriber list.</td></tr>
<tr><td><code>.fire(<em>extraargs</em>, ...)</code></td>
  <td>Sends a message to all the subscribers.
    Each receiver function gets (<code>baseargs</code> + <code>extraargs</code>)
    for arguments.</td></tr>
</table>

<a name="Color"><h3>Color (<code>utils.ts</code>)</h3></a>
<p>
A <code>Color</code> represents an RGBA value.
<table border>
<tr class=ctor><td><code>new Color(<u>r</u>, <u>g</u>, <u>b</u>, <u>a</u>=1.0)</code></td>
  <td>New <code>Color</code> object for RGBA values.</td></tr>
<tr><td><code>.r</code></td>
  <td>Red value.</td></tr>
<tr><td><code>.g</code></td>
  <td>Green value.</td></tr>
<tr><td><code>.b</code></td>
  <td>Blue value.</td></tr>
<tr><td><code>.a</code></td>
  <td>Alpha value.</td></tr>
<tr><td><code>.setAlpha(<u>a</u>)</code></td>
  <td>Creates a <code>Color</code> with a given alpha.</td></tr>
<tr><td><code>.multiply(<u>t</u>)</code></td>
  <td>Multiplies each component by <code>t</code>.</tr>
<tr><td><code>.blend(<u>color</u>, <u>t</u>)</code></td>
  <td>Blends with another <code>Color</code> with ratio <code>t</code>.</tr>
<tr><td><code>Color.generate(<u>h</u>, <u>v</u>=1.0)</code></td>
  <td>Creates a <code>Color</code> with a given hue.</td></tr>
</table>

<a name="Vec2"><h3>Vec2 (<code>geom.ts</code>)</h3></a>
<p>
A <code>Vec2</code> represents two-dimensional vector that has (x, y) elements.
<table border>
<tr class=ctor><td><code>new Vec2(<u>x</u>=0, <u>y</u>=0)</code></td>
  <td>New 2D vector (<code>x</code>, <code>y</code>).</td></tr>
<tr><td><code>.x</code></td>
  <td>X value.</td></tr>
<tr><td><code>.y</code></td>
  <td>Y value.</td></tr>
<tr><td><code>.copy()</code></td>
  <td>Duplicates the vector.</td></tr>
<tr><td><code>.equals(<u>p</u>)</code></td>
  <td><code>true</code> if the vector is identical to <code>p</code>.</td></tr>
<tr><td><code>.isZero()</code></td>
  <td><code>true</code> if the vector is zero length.</td></tr>
<tr><td><code>.len2()</code></td>
  <td>Length<sup>2</sup> of the vector.</td></tr>
<tr><td><code>.len()</code></td>
  <td>Length of the vector.</td></tr>
<tr><td><code>.sign()</code></td>
  <td>(<code>sign(x)</code>, <code>sign(y)</code>).</td></tr>
<tr><td><code>.add(<u>v</u>)</code></td>
  <td>(<code>this</code> + <code>v</code>).</td></tr>
<tr><td><code>.sub(<u>v</u>)</code></td>
  <td>(<code>this</code> - <code>v</code>).</td></tr>
<tr><td><code>.scale(<u>n</u>)</code></td>
  <td>(<code>n</code> &sdot; <code>this</code>).</td></tr>
<tr><td><code>.distance(<u>p</u>)</code></td>
  <td>|<code>this</code> - <code>p</code>|.</td></tr>
<tr><td><code>.clamp(<u>bounds</u>)</code></td>
  <td>(<code>clamp(x)</code>, <code>clamp(y)</code>).</td></tr>
<tr><td><code>.move(<u>dx</u>, <u>dy</u>)</code></td>
  <td>(<code>x+dx</code>, <code>y+dy</code>).</td></tr>
<tr><td><code>.interpolate(<u>p</u>, <u>t</u>)</code></td>
  <td>(<code>this*(1-t) + p*t)</code>.</td></tr>
<tr><td><code>.rotate(<u>d</u>)</code></td>
  <td>Creates a rotated vector in radian (clockwise...0&lt;<code>d</code>)</td></tr>
<tr><td><code>.rot90(<u>d</u>)</code></td>
  <td>Creates a rotated vector by 90 degrees (clockwise...0&lt;<code>d</code>)</td></tr>
<tr><td><code>.expand(<u>dw</u>, <u>dh</u>, <u>anchor</u>='c')</code></td>
  <td>Creates a <code>Rect</code> with the point as an anchor.</td></tr>
</table>

<a name="Vec3"><h3>Vec3 (<code>geom.ts</code>)</h3></a>
<p>
A <code>Vec3</code> represents three-dimensional vector that has (x, y, z) elements.
<table border>
<tr class=ctor><td><code>new Vec3(<u>x</u>=0, <u>y</u>=0, <u>z</u>=0)</code></td>
  <td>New 3D vector (<code>x</code>, <code>y</code>, <code>z</code>).</td></tr>
<tr><td><code>.x</code></td>
  <td>X value.</td></tr>
<tr><td><code>.y</code></td>
  <td>Y value.</td></tr>
<tr><td><code>.z</code></td>
  <td>Z value.</td></tr>
<tr><td><code>.copy()</code></td>
  <td>Duplicates the vector.</td></tr>
<tr><td><code>.equals(<u>p</u>)</code></td>
  <td><code>true</code> if <code>p</code> is identical.</td></tr>
<tr><td><code>.isZero()</code></td>
  <td><code>true</code> if the vector is zero length.</td></tr>
<tr><td><code>.len2()</code></td>
  <td>Length<sup>2</sup> of the vector.</td></tr>
<tr><td><code>.len()</code></td>
  <td>Length of the vector.</td></tr>
<tr><td><code>.sign()</code></td>
  <td>(<code>sign(x)</code>, <code>sign(y)</code>, <code>sign(z)</code>).</td></tr>
<tr><td><code>.add(<u>v</u>)</code></td>
  <td>(<code>this</code> + <code>v</code>).</td></tr>
<tr><td><code>.sub(<u>v</u>)</code></td>
  <td>(<code>this</code> - <code>v</code>).</td></tr>
<tr><td><code>.scale(<u>n</u>)</code></td>
  <td>(<code>n</code> &sdot; <code>this</code>).</td></tr>
<tr><td><code>.distance(<u>p</u>)</code></td>
  <td>|<code>this</code> - <code>p</code>|.</td></tr>
<tr><td><code>.clamp(<u>bounds</u>)</code></td>
  <td>(<code>clamp(x)</code>, <code>clamp(y)</code>, <code>clamp(z)</code>).</td></tr>
<tr><td><code>.move(<u>dx</u>, <u>dy</u>, <u>dz</u>)</code></td>
  <td>(<code>x+dx</code>, <code>y+dy</code>, <code>z+dz</code>).</td></tr>
<tr><td><code>.interpolate(<u>p</u>, <u>t</u>)</code></td>
  <td>(<code>this*(1-t) + p*t)</code>.</td></tr>
</table>

<a name="Collider"><h3>Collider (<code>geom.ts</code>)</h3></a>
<p>
A <code>Collider</code> is an abstract geometric object 
that can be used for hit detection.
<table border>
<tr><td><code>.copy()</code></td>
  <td>Duplicates the collider.</td></tr>
<tr><td><code>.move(<u>dx</u>, <u>dy</u>)</code></td>
  <td>Creates a collider moved by (<code>dx</code>, <code>dy</code>).</td></tr>
<tr><td><code>.add(<u>v</u>)</code></td>
  <td>Creates a collider moved by <code>v</code>.</td></tr>
<tr><td><code>.sub(<u>v</u>)</code></td>
  <td>Creates a collider moved by <code>-v</code>.</td></tr>
<tr><td><code>.equals(<u>collider</u>)</code></td>
  <td><code>true</code> if <code>collider</code> is identical.</td></tr>
<tr><td><code>.overlaps(<u>collider</u>)</code></td>
  <td><code>true</code> if this collider overlaps <code>collider</code>.</td></tr>
<tr><td><code>.contact(<u>v</u>, <u>collider</u>)</code></td>
  <td>Trims a vector so that <code>collider</code> doesn't collide with this.</td></tr>
<tr><td><code>.getAABB()</code></td>
  <td>Returns the AABB of the collider.</td></tr>
</table>

<a name="Shape"><h3>Shape : <a href="#Collider">Collider</a> (<code>geom.ts</code>)</h3></a>
<p>
A <code>Shape</code> is an abstract class that has a clear boundary and
represents an enclosed shape.
<table border>
<tr><td><code>.isZero()</code></td>
  <td><code>true</code> if the shape is empty.</td></tr>
<tr><td><code>.containsPt(<u>p</u>)</code></td>
  <td><code>true</code> if the shape contains <code>p</code>.</td></tr>
<tr><td><code>.edgePt(<u>t</u>)</code></td>
  <td>Returns a point on the contour.</td></tr>
<tr><td><code>.rndPt()</code></td>
  <td>Returns a random point within the shape.</td></tr>
<tr><td><code>.rndPtEdge()</code></td>
  <td>Returns a random point on the edge.</td></tr>
</table>

<a name="AALine"><h3>AALine : <a href="#Collider">Collider</a> (<code>geom.ts</code>)</h3></a>
<p>
A <code>AALine</code> represents an axis-aligned (either horizontal or
parpendicular) line.
<table border>
<tr class=ctor><td><code>new AALine(<u>x0</u>, <u>y0</u>, <u>x1</u>, <u>y1</u>)</code></td>
  <td>New AALine.</td></tr>
<tr><td><code>.x0</code></td>
  <td>Left x value.</td></tr>
<tr><td><code>.y0</code></td>
  <td>Top y value.</td></tr>
<tr><td><code>.x1</code></td>
  <td>Right x value.</td></tr>
<tr><td><code>.y1</code></td>
  <td>Bottom y value.</td></tr>
</table>

<a name="Rect"><h3>Rect : <a href="#Shape">Shape</a> (<code>geom.ts</code>)</h3></a>
<p>
A <code>Rect</code> object is a 2D rectangle that 
has its position (x, y) and size (width, height).
<table border>
<tr class=ctor><td><code>new Rect(<br>&nbsp; <u>x</u>=0, <u>y</u>=0,<br>&nbsp; <u>width</u>=0, <u>height</u>=0)</code></td>
  <td>New rectangle (<code>x</code>, <code>y</code>, <code>width</code>, <code>height</code>).</td></tr>
<tr><td><code>.x</code></td>
  <td>X value of the top-left corner.</td></tr>
<tr><td><code>.y</code></td>
  <td>Y value of the top-left corner.</td></tr>
<tr><td><code>.width</code></td>
  <td>Width of the rectangle.</td></tr>
<tr><td><code>.height</code></td>
  <td>Height of the rectangle.</td></tr>
<tr><td><code>.x1()</code></td>
  <td>X value of the right edge of the rectangle.</td></tr>
<tr><td><code>.y1()</code></td>
  <td>Y value of the bottom edge of the rectangle.</td></tr>
<tr><td><code>.cx()</code></td>
  <td>Center x of the rectangle.</td></tr>
<tr><td><code>.cy()</code></td>
  <td>Center y of the rectangle.</td></tr>
<tr><td><code>.center()</code></td>
  <td>Center point of the rectangle.</td></tr>
<tr><td><code>.topLeft()</code></td>
  <td>Top left corner of the rectangle.</td></tr>
<tr><td><code>.topRight()</code></td>
  <td>Top right corner of the rectangle.</td></tr>
<tr><td><code>.bottomLeft()</code></td>
  <td>Bottom left corner of the rectangle.</td></tr>
<tr><td><code>.bottomRight()</code></td>
  <td>Bottom right corner of the rectangle.</td></tr>
<tr><td><code>.anchor(<u>anchor</u>)</code></td>
  <td>Anchor point of the rectangle:
    <div style="margin-left:1em;">
      <svg xmlns="http://www.w3.org/2000/svg" 
	   xmlns:xlink="http://www.w3.org/1999/xlink"
	   version="1.1" width="125" height="49">
	<g transform="translate(2.5,2.5)">
	  <g fill="none" stroke="black" stroke-width="1">
	    <rect x="0" y="0" width="120" height="44" />
	    <circle cx="0" cy="0" r="2" />
	    <circle cx="60" cy="0" r="2" />
	    <circle cx="120" cy="0" r="2" />
	    <circle cx="0" cy="22" r="2" />
	    <circle cx="60" cy="22" r="2" />
	    <circle cx="120" cy="22" r="2" />
	    <circle cx="0" cy="44" r="2" />
	    <circle cx="60" cy="44" r="2" />
	    <circle cx="120" cy="44" r="2" />
	  </g>
	  <g style="font-family: monospace;">
	    <text x="0" y="11" text-anchor="begin">nw</text>
	    <text x="60" y="11" text-anchor="middle">n</text>
	    <text x="120" y="11" text-anchor="end">ne</text>
	    <text x="0" y="26" text-anchor="begin">w</text>
	    <text x="120" y="26" text-anchor="end">e</text>
	    <text x="0" y="41" text-anchor="begin">sw</text>
	    <text x="60" y="41" text-anchor="middle">s</text>
	    <text x="120" y="41" text-anchor="end">se</text>
	  </g>
	</g>
      </svg>
    </div>
  </td></tr>
<tr><td><code>.edge(<u>direction</u>)</code></td>
  <td>Returns an edge of the rectangle.
    <div style="margin-left:1em;">
      <svg xmlns="http://www.w3.org/2000/svg" 
	   xmlns:xlink="http://www.w3.org/1999/xlink"
	   version="1.1" width="125" height="49">
	<g transform="translate(2.5,2.5)">
	  <g fill="none" stroke="black" stroke-width="1">
	    <rect x="0" y="0" width="80" height="40" />
	    <g stroke-width="3">
	    <line x1="30" x2="50" y1="0" y2="0" />
	    <line x1="0" x2="0" y1="10" y2="30" />
	    <line x1="80" x2="80" y1="10" y2="30" />
	    <line x1="30" x2="50" y1="40" y2="40" />
	    </g>
	  </g>
	  <g style="font-family: monospace;">
	    <text x="40" y="11" text-anchor="middle">n</text>
	    <text x="2" y="25" text-anchor="begin">w</text>
	    <text x="78" y="25" text-anchor="end">e</text>
	    <text x="40" y="37" text-anchor="middle">s</text>
	  </g>
	</g>
      </svg>
    </div>
  </td></tr>
<tr><td><code>.inflate(<u>dw</u>, <u>dh</u>)</code></td>
  <td>Creates a inflated/deflated rectangle by (<code>dw&times;2</code>, <code>dh&times;2</code>):
    <div style="margin-left:1em;">
      <svg xmlns="http://www.w3.org/2000/svg" 
	   xmlns:xlink="http://www.w3.org/1999/xlink"
	   version="1.1" width="100" height="48">
	<g transform="translate(1.5,1.5)">
	  <g fill="none" stroke="black" stroke-width="1">
	    <rect x="20" y="12" width="50" height="20" />
	    <rect x="0" y="0" width="90" height="44" />
	    <line x1="0" y1="22" x2="20" y2="22" />
	    <line x1="45" y1="0" x2="45" y2="12" />
	    <line x1="45" y1="32" x2="45" y2="44" />
	    <line x1="70" y1="22" x2="90" y2="22" />
	    <circle cx="45" cy="22" r="2" />
	  </g>
	  <g style="font-size: 75%;">
	    <text x="1" y="20">dw</text>
	    <text x="46" y="11">dh</text>
	    <text x="46" y="43">dh</text>
	    <text x="71" y="20">dw</text>
	  </g>
	</g>
      </svg>
    </div>
  </td></tr>
<tr><td><code>.expand(<u>dw</u>, <u>dh</u>, <u>anchor</u>='c')</code></td>
  <td>Creates an expanded rectangle by (<code>dw&times;2</code>, <code>dh&times;2</code>).
    <div style="margin-left:1em;">
      <svg xmlns="http://www.w3.org/2000/svg" 
	   xmlns:xlink="http://www.w3.org/1999/xlink"
	   version="1.1" width="200" height="90">
	<marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
	  <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
	</marker>
	<g transform="translate(36.5,4.5)">
	  <g fill="none" stroke="black" stroke-width="1">
	    <rect x="30" y="30" width="40" height="20" />
	    <rect x="0" y="10" width="100" height="60" />
	    <line x1="0" y1="29" x2="100" y2="29" />
	    <line x1="0" y1="51" x2="100" y2="51" />
	    <line x1="29" y1="10" x2="29" y2="70" />
	    <line x1="71" y1="10" x2="71" y2="70" />
	    <g marker-end="url(#arrow)" stroke-width="2">
	      <line x1="25" y1="25" x2="5" y2="15" />
	      <line x1="75" y1="25" x2="95" y2="15" />
	      <line x1="25" y1="55" x2="5" y2="65" />
	      <line x1="75" y1="55" x2="95" y2="65" />
	      <line x1="25" y1="40" x2="5" y2="40" />
	      <line x1="75" y1="40" x2="95" y2="40" />
	      <line x1="50" y1="25" x2="50" y2="15" />
	      <line x1="50" y1="55" x2="50" y2="65" />
	    </g>
	  </g>
	  <g style="font-family: monospace;">
	    <text x="0" y="8" text-anchor="end">nw</text>
	    <text x="50" y="8" text-anchor="middle">n</text>
	    <text x="100" y="8" text-anchor="begin">ne</text>
	    <text x="0" y="45" text-anchor="end">w</text>
	    <text x="100" y="45" text-anchor="begin">e</text>
	    <text x="0" y="80" text-anchor="end">sw</text>
	    <text x="50" y="80" text-anchor="middle">s</text>
	    <text x="100" y="80" text-anchor="begin">se</text>
	  </g>
	</g>
      </svg>
    </div>
  </td></tr>
<tr><td><code>.resize(<u>w</u>, <u>h</u>, <u>anchor</u>='c')</code></td>
  <td>Creates a resized rectangle.
    <div style="margin-left:1em;">
      <svg xmlns="http://www.w3.org/2000/svg" 
	   xmlns:xlink="http://www.w3.org/1999/xlink"
	   version="1.1" width="200" height="90">
	<marker id="arrow" viewBox="-5 -5 10 10" orient="auto">
	  <polygon points="-5,-5 5,0 -5,5" fill="black" stroke="none" />
	</marker>
	<g transform="translate(36.5,4.5)">
	  <g fill="none" stroke="black" stroke-width="1">
	    <rect x="30" y="30" width="40" height="20" />
	    <rect x="0" y="10" width="100" height="60" />
	    <line x1="0" y1="29" x2="100" y2="29" />
	    <line x1="0" y1="51" x2="100" y2="51" />
	    <line x1="29" y1="10" x2="29" y2="70" />
	    <line x1="71" y1="10" x2="71" y2="70" />
	    <g marker-end="url(#arrow)" stroke-width="2">
	      <line x1="25" y1="25" x2="5" y2="15" />
	      <line x1="75" y1="25" x2="95" y2="15" />
	      <line x1="25" y1="55" x2="5" y2="65" />
	      <line x1="75" y1="55" x2="95" y2="65" />
	      <line x1="25" y1="40" x2="5" y2="40" />
	      <line x1="75" y1="40" x2="95" y2="40" />
	      <line x1="50" y1="25" x2="50" y2="15" />
	      <line x1="50" y1="55" x2="50" y2="65" />
	    </g>
	  </g>
	  <g style="font-family: monospace;">
	    <text x="0" y="8" text-anchor="end">nw</text>
	    <text x="50" y="8" text-anchor="middle">n</text>
	    <text x="100" y="8" text-anchor="begin">ne</text>
	    <text x="0" y="45" text-anchor="end">w</text>
	    <text x="100" y="45" text-anchor="begin">e</text>
	    <text x="0" y="80" text-anchor="end">sw</text>
	    <text x="50" y="80" text-anchor="middle">s</text>
	    <text x="100" y="80" text-anchor="begin">se</text>
	  </g>
	</g>
      </svg>
    </div>
  </td></tr>
<tr><td><code>.xdistance(<u>rect</u>)</code></td>
  <td>X-distance to <code>rect</code>.</td></tr>
<tr><td><code>.ydistance(<u>rect</u>)</code></td>
  <td>Y-distance to <code>rect</code>.</td></tr>
<tr><td><code>.containsRect(<u>rect</u>)</code></td>
  <td><code>true</code> if the rectangle contains <code>rect</code>.</td></tr>
<tr><td><code>.overlapsRect(<u>rect</u>)</code></td>
  <td><code>true</code> if the rectangle overlaps <code>rect</code>.</td></tr>
<tr><td><code>.overlapsCircle(<u>circle</u>)</code></td>
  <td><code>true</code> if the rectangle overlaps <code>circle</code>.</td></tr>
<tr><td><code>.union(<u>rect</u>)</code></td>
  <td>Combines two rectangles (union).</td></tr>
<tr><td><code>.intersection(<u>rect</u>)</code></td>
  <td>Combines two rectangles (intersection).</td></tr>
<tr><td><code>.clamp(<u>bounds</u>)</code></td>
  <td>Moves the rectangle so that it fits <code>bounds</code>.</td></tr>
<tr><td><code>.modPt(<u>p</u>)</code></td>
  <td>Creates a modulo point with the rectangle.</td></tr>
<tr><td><code>.contactRect(<u>v</u>, <u>rect</u>)</code></td>
  <td>Trims a vector so that <code>rect</code> doesn't collide with this.</td></tr>
<tr><td><code>.boundRect(<u>v</u>, <u>rect</u>)</code></td>
  <td>Trims a vector so that <code>rect</code> is restricted inside this.</td></tr>
</table>

<a name="Circle"><h3>Circle : <a href="#Shape">Shape</a> (<code>geom.ts</code>)</h3></a>
<p>
A <code>Circle</code> represents a circle that has its center and radius.
<table border>
<tr class=ctor><td><code>new Circle(<u>center</u>, <u>radius</u>=0)</code></td>
  <td>New circle with the given center and radius.</td></tr>
<tr><td><code>.center</code></td>
  <td>Center of the circle.</td></tr>
<tr><td><code>.radius</code></td>
  <td>Radius of the circle.</td></tr>
<tr><td><code>.inflate(<u>dr</u>)</code></td>
  <td>Creates a inflated/deflated circle by <code>dr</code>.</tr></tr>
<tr><td><code>.resize(<u>radius</u>)</code></td>
  <td>Creates a resized circle.</tr></tr>
<tr><td><code>.distance(<u>p</u>)</code></td>
  <td>Distance to point <code>p</code>.</td></tr>
<tr><td><code>.containsCircle(<u>circle</u>)</code></td>
  <td><code>true</code> if the circle contains another <code>circle</code>.</td></tr>
<tr><td><code>.overlapsCircle(<u>circle</u>)</code></td>
  <td><code>true</code> if the circle overlaps another <code>circle</code>.</td></tr>
<tr><td><code>.overlapsRect(<u>rect</u>)</code></td>
  <td><code>true</code> if the circle overlaps <code>rect</code>.</td></tr>
<tr><td><code>.clamp(<u>bounds</u>)</code></td>
  <td>Moves the circle so that it fits <code>bounds</code>.</td></tr>
<tr><td><code>.contactCircle(<u>v</u>, <u>circle</u>)</code></td>
  <td>Trims a vector so that <code>circle</code> doesn't collide with this.</td></tr>
</table>

<a name="AAPlane"><h3>AAPlane (<code>geom.ts</code>)</h3></a>
<p>
A <code>AAPlane</code> represents an axis-aligned plane. 
It is represented by two axis-aligned (either X, Y or Z) points.
If two points are not aligned by any axis, it is invalid.
<table border>
<tr class=ctor><td><code>new AAPlane(<u>p0</u>, <u>p1</u>)</code></td>
  <td>New AAPlane for the given points.</td></tr>
<tr><td><code>.p0</code></td>
  <td>Point 0.</td></tr>
<tr><td><code>.p1</code></td>
  <td>Point 1.</td></tr>
</table>

<a name="Box"><h3>Box (<code>geom.ts</code>)</h3></a>
<p>
A <code>Box</code> is a 3D cuboid that has its position and size
both as <code>Vec3</code>.
<table border>
<tr class=ctor><td><code>new Box(<u>origin</u>, <u>size</u>=null)</code></td>
  <td>New Box with (<code>origin</code>, <code>size</code>).</td></tr>
<tr><td><code>.origin</code></td>
  <td>Origin of the box.</td></tr>
<tr><td><code>.size</code></td>
  <td>Size of the box.</td></tr>
<tr><td><code>.copy()</code></td>
  <td>Duplicates the box.</td></tr>
<tr><td><code>.equals(<u>box</u>)</code></td>
  <td><code>true</code> if <code>box</code> is identical.</td></tr>
<tr><td><code>.isZero()</code></td>
  <td><code>true</code> if the box is empty.</td></tr>
<tr><td><code>.center()</code></td>
  <td>Center of the box.</td></tr>
<tr><td><code>.surface(<u>vx</u>, <u>vy</u>, <u>vz</u>)</code></td>
  <td>Returns the <code>AAPlane</code> of the given surface.</td></tr>
<tr><td><code>.anchor(<u>vx</u>=0, <u>vy</u>=0, <u>vz</u>=0)</code></td>
  <td>Anchor point of the box.</td></tr>
<tr><td><code>.move(<u>dx</u>, <u>dy</u>, <u>dz</u>)</code></td>
  <td>Creates a box moved by (<code>dx</code>, <code>dy</code>, <code>dz</code>).</td></tr>
<tr><td><code>.add(<u>v</u>)</code></td>
  <td>Creates a box moved by <code>v</code>.</td></tr>
<tr><td><code>.sub(<u>v</u>)</code></td>
  <td>Creates a box moved by <code>-v</code>.</td></tr>
<tr><td><code>.inflate(<u>dx</u>, <u>dy</u>, <u>dz</u>)</code></td>
  <td>Creates a inflated/deflated box by (<code>dx</code>, <code>dy</code>, <code>dz</code>).</td></tr>
<tr><td><code>.xdistance(<u>box</u>)</code></td>
  <td>X-distance to <code>box</code>.</td></tr>
<tr><td><code>.ydistance(<u>box</u>)</code></td>
  <td>Y-distance to <code>box</code>.</td></tr>
<tr><td><code>.zdistance(<u>box</u>)</code></td>
  <td>Z-distance to <code>box</code>.</td></tr>
<tr><td><code>.union(<u>box</u>)</code></td>
  <td>Combines two boxes (union).</td></tr>
<tr><td><code>.intersection(<u>box</u>)</code></td>
  <td>Combines two boxes (intersection).</td></tr>
<tr><td><code>.clamp(<u>bounds</u>)</code></td>
  <td>Moves the box so that it fits <code>bounds</code>.</td></tr>
<tr><td><code>.rndPt()</code></td>
  <td>Creates a random point within the box.</td></tr>
<tr><td><code>.containsPt(<u>p</u>)</code></td>
  <td><code>true</code> if the box contains <code>p</code>.</td></tr>
<tr><td><code>.overlapsBox(<u>box</u>)</code></td>
  <td><code>true</code> if the box overlaps <code>box</code>.</td></tr>
<tr><td><code>.contactBox(<u>v</u>, <u>box</u>)</code></td>
  <td>Trims a vector so that <code>box</code> doesn't collide with this.</td></tr>
<tr><td><code>.union(<u>box</u>)</code></td>
  <td>Combines two boxes (union).</td></tr>
<tr><td><code>.intersection(<u>box</u>)</code></td>
  <td>Combines two boxses (intersection).</td></tr>
<tr><td><code>.clamp(<u>bounds</u>)</code></td>
  <td>Moves the box so that it fits <code>bounds</code>.</td></tr>
</table>

<a name="TileMap"><h3>TileMap (<code>tilemap.ts</code>)</h3></a>
<p>
A <code>TileMap</code> represents a two-dimensional array that holds map tiles.
<table border>
<tr class=ctor><td><code>new TileMap(<br>&nbsp; <u>tilesize</u>, <u>width</u>, <u>height</u>, <br>&nbsp; <u>map</u>=null)</code></td>
  <td>New TileMap for a given size.</td></tr>
<tr><td><code>.tilesize</code></td>
  <td>Tile size.</td></tr>
<tr><td><code>.width</code></td>
  <td>Number of tiles that fit horizontally in the map.</td></tr>
<tr><td><code>.height</code></td>
  <td>Number of tiles that fit vertically in the map.</td></tr>
<tr><td><code>.bounds</code></td>
  <td>Bounds of the map in the actual size.</td></tr>
<tr><td><code>.map</code></td>
  <td>Int32Array[] for the map data. Optionally given at construction.</td></tr>
<tr><td><code>.get(<u>x</u>, <u>y</u>)</code></td>
  <td>Gets a tile at a specific position.</td></tr>
<tr><td><code>.set(<u>x</u>, <u>y</u>, <u>c</u>)</code></td>
  <td>Sets a tile at a specific position. (Clears the RangeMap cache.)</td></tr>
<tr><td><code>.fill(<u>c</u>, <u>rect</u>=null)</code></td>
  <td>Fills tiles in a given area.</td></tr>
<tr><td><code>.copy()</code></td>
  <td>Copies the tilemap.</td></tr>
<tr><td><code>.coord2map(<u>rect</u>)</code></td>
  <td>Converts an actual Rect/Vec2 to the tile cells.</td></tr>
<tr><td><code>.map2coord(<u>rect</u>)</code></td>
  <td>Converts a Rect/Vec2 for tile cells to the actual size.</td></tr>
<tr><td><code>.apply(<br>&nbsp; <u>(x,y,c) =&gt; boolean</u>,<br>&nbsp; <u>rect</u>=null)</code></td>
  <td>Applies a function to tiles.</td></tr>
<tr><td><code>.shift(<u>vx</u>, <u>vy</u>, <u>rect</u>=null)</code></td>
  <td>Shift all the cells in the given area.</td></tr>
<tr><td><code>.findTile(<br>&nbsp; <u>(c) =&gt; boolean</u>, <br>&nbsp; <u>rect</u>=null)</code></td>
  <td>Returns the position of the first tile in the given area.</td></tr>
<tr><td><code>.findTileByCoord(<br>&nbsp; <u>(c) =&gt; boolean</u>, <br>&nbsp; <u>range</u>)</code></td>
  <td>Returns the position of the first tile in the given area.</td></tr>
<tr><td><code>.getTileRects(<br>&nbsp; <u>(c) =&gt; boolean</u>, <br>&nbsp; <u>range</u>)</code></td>
  <td>Returns a list of actual rectangles for tiles.</td></tr>
<tr><td><code>.getRangeMap(<br>&nbsp; <u>key</u>, <br>&nbsp; <u>(c) =&gt; boolean</u>)</code></td>
  <td>Creates a <code>RangeMap</code> object for this tilemap.</td></tr>
<tr><td><code>.renderFromBottomLeft(<br>&nbsp; <u>ctx</u>, <u>ft</u>,<br>&nbsp; <u>x0</u>=0, <u>y0</u>=0, <u>w</u>=0, <u>h</u>=0)</code></td>
  <td>Renders the tiles from bottom left for a given tile set.</td></tr>
<tr><td><code>.renderFromTopRight(<br>&nbsp; <u>ctx</u>, <u>ft</u>,<br>&nbsp; <u>x0</u>=0, <u>y0</u>=0, <u>w</u>=0, <u>h</u>=0)</code></td>
  <td>Renders the tiles from top right for a given tile set.</td></tr>
<tr><td><code>.renderWindowFromBottomLeft(<br>&nbsp; <u>ctx</u>, <u>window</u>, <u>ft</u>)</code></td>
  <td>Renders the tiles from bottom left within a window.</td></tr>
<tr><td><code>.renderWindowFromTopRight(<br>&nbsp; <u>ctx</u>, <u>window</u>, <u>ft</u>)</code></td>
  <td>Renders the tiles from top right within a window.</td></tr>
</table>

<a name="RangeMap"><h3>RangeMap (<code>tilemap.ts</code>)</h3></a>
<p>
A <code>RangeMap</code> is a partial copy of <code>TileMap</code> 
that allows range queries for specific tiles.
Notice: This object is always returned by <code>TileMap.getRangeMap()</code> method
and not explicitly created by a user.
<table border>
<tr><td><code>.width</code></td>
  <td>Number of tiles that fit horizontally in the map.</td></tr>
<tr><td><code>.height</code></td>
  <td>Number of tiles that fit vertically in the map.</td></tr>
<tr><td><code>.get(<u>x0</u>, <u>y0</u>, <u>x1</u>, <u>y1</u>)</code></td>
  <td>Returns the number of specific tiles within the given area.</td></tr>
<tr><td><code>.exists(<u>rect</u>)</code></td>
  <td><code>true</code> if a specific tile exists within the given area.</td></tr>
</table>

<a name="SpriteSheet"><h3>SpriteSheet (<code>sprite.ts</code>)</h3></a>
<p>
A set of <code>ImageSource</code> objects indexed by a number.
<table border>
<tr class=ctor><td><code>new ImageSpriteSheet(image, size, <em>[origin]</em>)</code></td>
  <td>Creates a <code>SpriteSheet</code> from <code>&lt;img&gt;</code>.</td></tr>
<tr class=ctor><td><code>new SimpleSpriteSheet(imgsrcs)</code></td>
  <td>Creates a <code>SpriteSheet</code> with solid colors.</td></tr>
<tr><td><code>.get(i, <em>[j, [w, [h, [origin]]]]</em>)</code></td>
  <td>Returns the <code>i,j</code>-th <code>ImageSource</code>.</td></tr>
</table>

<a name="PhysicsConfig"><h3>PhysicsConfig (<code>entity.ts</code>)</h3></a>
<p>
<table border>
<tr class=ctor><td><code>new PhysicsConfig()</code></td>
  <td>Creates a new configuration.</td></tr>
<tr><td><code>.maxspeed</code></td>
  <td>Vector for the maximum speed (absolute values).</td></tr>
<tr><td><code>.jumpfunc</code></td>
  <td>Gravity function <code>(vy, t) =&gt; number</code></td></tr>
<tr><td><code>.isObstacle</code></td>
  <td>Function <code>(c) =&gt; boolean</code> that returns true if the tile is an obstacle.</td></tr>
<tr><td><code>.isGrabbable</code></td>
  <td>Function <code>(c) =&gt; boolean</code> that returns true if the tile is grabbable (e.g. ladders).</td></tr>
<tr><td><code>.isStoppable</code></td>
  <td>Function <code>(c) =&gt; boolean</code> that returns true if the tile is stoppable.</td></tr>
</table>

<a name="TaskList"><h3>TaskList (<code>task.ts</code>)</h3></a>
<p>
Manages a list of <code>Task</code>s.
<table border>
<tr class=ctor><td><code>new ParallelTaskList()</code></td>
  <td>Tasklist that runs given tasks parallelly.</td></tr>
<tr class=ctor><td><code>new SequentialTaskList()</code></td>
  <td>Tasklist that runs given tasks sequentially.</td></tr>
<tr><td><code>.init()</code></td>
  <td>Initializes the task list.</td></tr>
<tr><td><code>.tick()</code></td>
  <td>Invoked at every frame. Update the current tasks.</td></tr>
<tr><td><code>.add(task)</code></td>
  <td>Adds a task to the list.</td></tr>
<tr><td><code>.remove(task)</code></td>
  <td>Removes a task from the list.</td></tr>
</table>

<a name="TaskQueue"><h3>TaskQueue (<code>task.ts</code>)</h3></a>
<p>
Manages a list of <code>Task</code>s that run sequentially.
<table border>
<tr class=ctor><td><code>new TaskQueue()</code></td>
  <td>Creates an empty task queue.</td></tr>
<tr><td><code>.stopWhenEmpty</code></td>
  <td>Set <code>true</code> to automatically kill the queue when there's no <code>Task</code>.</td></tr>
<tr><td><code>.getCurrentTask()</code></td>
  <td>Returns a task that is currently running.</td></tr>
<tr><td><code>.add(task)</code></td>
  <td>Adds a task to the list.</td></tr>
<tr><td><code>.remove(task)</code></td>
  <td>Removes a task from the list.</td></tr>
<tr><td><code>.clear()</code></td>
  <td>Empties the task list.</td></tr>
<tr><td><code>.tick()</code></td>
  <td>Invoked at every frame. Update the current tasks.</td></tr>
</table>

<a name="EntityWorld"><h3>EntityWorld (<code>entity.ts</code>)</h3></a>
<a name="SpriteLayer"><h3>SpriteLayer (<code>sprite.ts</code>)</h3></a>

<a name="basic-objects"><h2>Basic Objects</h2></a>

<a name="ImageSource"><h3>ImageSource (<code>sprite.ts</code>)</h3></a>
<p>
An <code>ImageSource</code> is an abstract object to render something on screen.
<table border>
<tr class=ctor><td><code>new RectImageSource(<u>color</u>, <u>dstRect</u>)</code></td>
  <td>ImageSource with a filled rectangle.</td></tr>
<tr class=ctor><td><code>new OvalImageSource(<u>color</u>, <u>dstRect</u>)</code></td>
  <td>ImageSource with a filled oval.</td></tr>
<tr class=ctor><td><code>new CanvasImageSource(<br>&nbsp; <u>canvas</u>, <u>srcRect</u>=null, <u>dstRect</u>=null)</code></td>
  <td>ImageSource that refers to a portion of 
    <code>&lt;canvas&gt;</code> element.</td></tr>
<tr class=ctor><td><code>new HTMLImageSource(<br>&nbsp; <u>image</u>, <u>srcRect</u>=null, <u>dstRect</u>=null)</code></td>
  <td>ImageSource that refers to a portion of
    <code>&lt;img&gt;</code> element.</td></tr>
<tr class=ctor><td><code>new TiledImageSource(<br>&nbsp; <u>imgsrc</u>, <u>bounds</u>, <u>offset</u>=null)</code></td>
  <td>ImageSource that is composed of another ImageSource.</td></tr>
<tr class=ctor><td><code>new StarImageSource(<br>&nbsp; <u>bounds</u>, <u>nstars</u>, <u>maxdepth</u>=3, <u>imgsrcs</u>=null)</code></td>
  <td>ImageSource that can be used for "star flowing" effects.</td></tr>
<tr><td><code>.getBounds()</code></td>
  <td>Returns the bounds rectangle of the ImageSource.</td></tr>
<tr><td><code>.render(<u>ctx</u>)</code></td>
  <td>Renders the image at (0, 0) in the given Context.</td></tr>
</table>

<a name="Sprite"><h3>Sprite (<code>sprite.ts</code>)</h3></a>
<p>
A <code>Sprite</code> is something to be displayed. 
It has a location, rotation and scale. Typically it does not move by itself.
A <code>Scene</code> or <code>Entity</code> is responsible to change its position.
<table border>
<tr class=ctor><td><code>new FixedSprite(<br>&nbsp; <u>imgsrc</u>=null, <u>pos</u>=null)</code></td>
  <td>Sprite with a fixed <code>ImageSource</code> and position.</td></tr>
<tr class=ctor><td><code>new EntitySprite(<u>entity</u>)</code></td>
  <td>Sprite that belongs to an <code>Entity</code>.</td></tr>
<tr><td><code>.visible</code></td>
  <td><code>true</code> if the sprite is visible.</td></tr>
<tr><td><code>.scale</code></td>
  <td>Vector for the scale of the sprite image.</td></tr>
<tr><td><code>.rotation</code></td>
  <td>Rotation of the sprite image (in radian).</td></tr>
<tr><td><code>.getBounds([pos])</code></td>
  <td>Returns the bounds for the given <code>pos</code>.</td></tr>
<tr><td><code>.render(ctx)</code></td>
  <td>Draws the sprite at the given position.</td></tr>
<tr class=override><td><code>.getSkin()</code></td>
  <td>Returns the <code>ImageSource</code> of the sprite's content.</td></tr>
<tr class=override><td><code>.getPos()</code></td>
  <td>Returns the position of the sprite.</td></tr>
<tr class=override><td><code>.mouseSelectable(p)</code></td>
  <td>Returns <code>true</code> if the sprite can be focused for the given position.</td></tr>
<tr class=override><td><code>.renderImage(ctx)</code></td>
  <td>Draws the actual image of the sprite.</td></tr>
</table>

<a name="Task"><h3>Task (<code>task.ts</code>)</h3></a>
<p>
A <code>Task</code> is an independent object that runs by itself
and managed by <code>TaskList</code>.
<table border>
<tr class=ctor><td><code>new Task()</code></td>
  <td>Creates a new empty task.</td></tr>
<tr class=ctor><td><code>new DelayTask(<br>&nbsp; <u>delay</u>, <u>proc</u>=null)</code></td>
  <td>Task that waits a certain amount and then execute the given function.</td></tr>
<tr class=ctor><td><code>new SoundTask(<br>&nbsp; <u>sound</u>, <u>soundStart</u>=MP3_GAP, <u>soundEnd</u>=0)</code></td>
  <td>Task that plays a sound.</td></tr>
<tr><td><code>.state</code></td>
  <td>Either one of <code>Scheduled</code>, <code>Running</code> or <code>Finished</code>.</td>
<tr><td><code>.tasklist</code></td>
  <td><code>TaskList</code> that the task belongs to.</td></tr>
<tr><td><code>.lifetime</code></td>
  <td>Duration that the task can run.</td></tr>
<tr><td><code>.startTime</code></td>
  <td>Time the task started.</td></tr>
<tr><td><code>.stopped</code></td>
  <td>Signal fired when the task stops.</td></tr>
<tr><td><code>.getTime()</code></td>
  <td>Elapsed time since the task has started (in seconds).</td></tr>
<tr><td><code>.start()</code></td>
  <td>Invoked when the task is started.</td></tr>
<tr><td><code>.stop()</code></td>
  <td>Terminates the task.</td></tr>
<tr><td><code>.tick()</code></td>
  <td>Invoked at every frame while the task is running.</td></tr>
<tr><td><code>.chain(next)</code></td>
  <td>Schedules another task.</td></tr>
<tr class=override><td><code>.update()</code></td>
  <td>Updates for the current frame.</td></tr>
</table>

<a name="Widget"><h3>Widget : <a href="#Task">Task</a> (<code>entity.ts</code>)</h3></a>
<p>
A <code>Widget</code> is a task that belongs to a <code>Layer</code> and
has some visual aspect.
<table border>
<tr class=ctor><td><code>new Widget()</code></td>
  <td>Creates a new widget.</td></tr>
</table>

<a name="Entity"><h3>Entity : <a href="#Widget">Widget</a> (<code>entity.ts</code>)</h3></a>
<p>
An <code>Entity</code> is a bit like a GameObject in Unity.  
(Unlike Unity, however, Euskit uses a traditional hierarchical model 
instead of components.)
Each Entity has its own process, <code>Collider</code> and one or more
<code>Sprite</code>s.
Once you place an Entity in the game world, it moves on its own.
A <code>Rect</code> is typically used for <code>Collider</code> in 2D games.
<table border>
<tr class=ctor><td><code>new Entity(pos)</code></td>
  <td>Creates a new entity.</td></tr>
<tr><td><code>.sprite</code></td>
  <td>A <code>Sprite</code> that belongs to this entity.</td></tr>
<tr><td><code>.collider</code></td>
  <td>A <code>Rect</code>/<code>Circle</code> for the entity's collider.</td></tr>
<tr><td><code>.getCollider([pos])</code></td>
  <td>Returns the collider for the given <code>pos</code>.</td></tr>
<tr><td><code>.canMove(v)</code></td>
  <td><code>true</code> if the entity is movable toward <code>v</code>.</td></tr>
<tr><td><code>.getMove(v)</code></td>
  <td>Trims the vector <code>v</code> so that it doesn't collide.</td></tr>
<tr><td><code>.movePos(v)</code></td>
  <td>Moves the entity by <code>v</code>.</td></tr>
<tr><td><code>.moveIfPossible(v, <em>[context]</em>)</code></td>
  <td>Moves the entity by <code>v</code> without colliding obstacles.</td></tr>
<tr class=override><td><code>.getObstaclesFor(range, context)</code></td>
  <td>Returns a list of <code>Shape</code>s within <code>range</code>.</td></tr>
<tr class=override><td><code>.getFencesFor(range, context)</code></td>
  <td>Returns a list of bounding rectangles that limits the entity within.</td></tr>
<tr class=override><td><code>.collidedWith(entity)</code></td>
  <td>Invoked when the entity collides another entity.</td></tr>
</table>

<a name="Layer"><h3>Layer (<code>layer.ts</code>)</h3></a>
<p>
A <code>Layer</code> contains a set of objects that can be rendered 
at once and interact each other.
<table border>
<tr class=ctor><td><code>new Layer()</code></td>
  <td>Creates a new layer.</td></tr>
<tr><td><code>.time</code></td>
  <td>The current time of the layer (in seconds).</td></tr>
<tr><td><code>.tasks</code></td>
  <td>A list of <code>Task</code>s that belong to the layer.</td></tr>
<tr><td><code>.sprites</code></td>
  <td>A list of <code>Sprite</code>s that belong to the layer.</td></tr>
<tr><td><code>.entities</code></td>
  <td>A list of <code>Entity</code>s that belong to the layer.</td></tr>
<tr><td><code>.addTask(task)</code></td>
  <td>Adds a <code>Task</code> to the list.</td></tr>
<tr><td><code>.addSprite(sprite)</code></td>
  <td>Adds a <code>Sprite</code> to the list.</td></tr>
<tr><td><code>.removeSprite(sprite)</code></td>
  <td>Removes a <code>Sprite</code> from the list.</td></tr>
<tr><td><code>.addEntity(entity)</code></td>
  <td>Adds an <code>Entity</code> to the list.</td></tr>
<tr><td><code>.removeEntity(sprite)</code></td>
  <td>Removes an <code>Entity</code> from the list.</td></tr>
<tr><td><code>.moveAll(v)</code></td>
  <td>Moves all the sprites by <code>v</code>.</td></tr>
<tr><td><code>.findEntities(f, <em>[entities]</em>)</code></td>
  <td>Returns a list of entities specified by function <code>f</code>.</td></tr>
<tr><td><code>.findSpriteAt(p)</code></td>
  <td>Returns a Sprite that is located at <code>p</code>.</td></tr>
<tr><td><code>.onMouseDown(p, button)</code></td>
  <td>Invoked when a mouse button is pressed.
<tr><td><code>.onMouseUp(p, button)</code></td>
  <td>Invoked when a mouse button is released.
<tr><td><code>.onMouseMove(p)</code></td>
  <td>Invoked when a mouse pointer is moved.
<tr class=override><td><code>.init()</code></td>
  <td>Invoked when the layer is initialized.</td></tr>
<tr class=override><td><code>.tick(t)</code></td>
  <td>Invoked for every frame.</td></tr>
<tr class=override><td><code>.render(ctx, bx, by)</code></td>
  <td>Draws all the sprites at the location (<code>bx</code>, <code>by</code>).</td></tr>
</table>

<a name="Scene"><h3>Scene (<code>scene.ts</code>)</h3></a>
<p>
A <code>Scene</code> can be thought of a mini-app or "mode" within the App.  
It's pretty much an event handler that manages the in-game states.
This is primarily what a Euskit user will write. Euskit supports
multiple Scenes, but it's possible to create an entire game with just
one Scene.
<table border>
<tr class=ctor><td><code>new Scene()</code></td>
  <td>Creates a new scene.</td></tr>
<tr><td><code>.screen</code></td>
  <td>The canvas rectangle.</td></tr>
<tr><td><code>.changeScene(scene)</code></td>
  <td>Signals the <code>App</code> to switch to a scene.</td></tr>
<tr class=override><td><code>.init()</code></td>
  <td>Initializes the scene.</td></tr>
<tr class=override><td><code>.tick(t)</code></td>
  <td>Invoked for every frame.</td></tr>
<tr class=override><td><code>.render(ctx, bx, by)</code></td>
  <td>Draws the scene at the location (<code>bx</code>, <code>by</code>).</td></tr>
<tr class=override><td><code>.onDirChanged(v)</code></td>
  <td>Invoked when a directional input is changed.</td></tr>
<tr class=override><td><code>.onButtonPressed(keySym)</code></td>
  <td>Invoked when the button state is pressed.</td></tr>
<tr class=override><td><code>.onButtonReleased(keySym)</code></td>
  <td>Invoked when the button state is released.</td></tr>
<tr class=override><td><code>.onKeyDown(keyCode)</code></td>
  <td>Invoked when a key is pressed.</td></tr>
<tr class=override><td><code>.onKeyUp(keyCode)</code></td>
  <td>Invoked when a key is released.</td></tr>
<tr class=override><td><code>.onKeyPress(charCode)</code></td>
  <td>Invoked when a character is typed.</td></tr>
<tr class=override><td><code>.onMouseDown(p, button)</code></td>
  <td>Invoked when a mouse button is pressed.</td></tr>
<tr class=override><td><code>.onMouseUp(p, button)</code></td>
  <td>Invoked when a mouse button is released.</td></tr>
<tr class=override><td><code>.onMouseMove(p)</code></td>
  <td>Invoked when a mouse pointer is moved.</td></tr>
</table>

<a name="App"><h3>App (<code>app.ts</code>)</h3></a>
<p>
Every game has exactly one <code>App</code> object.
It does the basic pluming and resource management; it has
an event loop and connect all the external parts (i.e. a browser)
to the game. Typically, you don't have to change this part.
<table border>
<tr class=ctor><td><code>new App(size, framerate, elem)</code></td>
  <td>Creates a new app with given HTML5 resources.</td></tr>
<tr><td><code>.size</code></td>
  <td>The canvas size.</td></tr>
<tr><td><code>.framerate</code></td>
  <td>The framerate.</td></tr>
<tr><td><code>.elem</code></td>
  <td>The HTML element where a canvas is embedded.</td></tr>
<tr><td><code>.canvas</code></td>
  <td>The <code>&lt;canvas&gt;</code> element.</td></tr>
<tr><td><code>.ctx</code></td>
  <td>The <code>CanvasRenderingContext2D</code> object.</td></tr>
<tr><td><code>.audioContext</code></td>
  <td>The <code>AudioContext</code> object.</td></tr>
<tr><td><code>.images</code></td>
  <td>Set of available <code>HTMLImageElement</code> objects.</td></tr>
<tr><td><code>.sounds</code></td>
  <td>Set of available <code>HTMLAudioElement</code> objects.</td></tr>
<tr><td><code>.labels</code></td>
  <td>Set of available <code>HTMLDivElement</code> objects.</td></tr>
<tr><td><code>.scene</code></td>
  <td>The current <code>Scene</code>.</td></tr>
<tr><td><code>.active</code></td>
  <td><code>true</code> if the game is running.</td></tr>
<tr><td><code>.keys[]</code></td>
  <td>The states of the current keys.</td></tr>
<tr><td><code>.keyDir</code></td>
  <td>The state of the current directional input.</td></tr>
<tr><td><code>.mousePos</code></td>
  <td>The current position of the mouse pointer.</td></tr>
<tr><td><code>.mouseButton</code></td>
  <td>The current state of the mouse button.</td></tr>

<tr><td><code>.addElement(bounds)</code></td>
  <td>Adds a new <code>&lt;div&gt;</code> element to the canvas.</td></tr>
<tr><td><code>.removeElement(elem)</code></td>
  <td>Removes the element from the canvas.</td></tr>
<tr><td><code>.lockKeys(<u>t</u>=1)</code></td>
  <td>Blocks keyboard input for the given duration.</td></tr>
<tr><td><code>.setMusic(<br>&nbsp; <u>name</u>=null, <u>start</u>=0, <u>end</u>=0)</code></td>
  <td>Starts playing the music. When <code>null</code> is given, stops playing.</td></tr>
<tr><td><code>.playSound(<u>name</u>, <u>start</u>=0)</code></td>
  <td>Plays the specified sound.</td></tr>
<tr><td><code>.init(scene)</code></td>
  <td>Initializes the game with the first <code>Scene</code>.</td></tr>
<tr><td><code>.post(msg)</code></td>
  <td>Queues a function that is to be executed at the end of the frame.</td></tr>
</table>


<a name="specialized-objects"><h2>Specialized Objects</h2></a>

<a name="TiledSprite"><h3>TiledSprite : <a href="#Sprite">Sprite</a> (<code>sprite.ts</code>)</h3></a>
<p>
A <code>Sprite</code> shows an image repeatedly within the bounds.
Suitable for backgrounds.
<table border>
<tr class=ctor><td><code>new TiledSprite(bounds)</code></td>
  <td>Creates a new sprite.</td></tr>
<tr class=inherited><td><code>.imgsrc</code></td>
  <td>A <code>ImageSource</code> for the sprite's content.</td></tr>
<tr><td><code>.offset</code></td>
  <td>The offset of the image (in <code>Vec2</code>).</td></tr>
</table>

<a name="StarSprite"><h3>StarSprite : <a href="#Sprite">Sprite</a> (<code>sprite.ts</code>)</h3></a>
<p>
A <code>Sprite</code> that shows multiple parallaxed stars. 
Suitable for space-y backgrounds.
<table border>
<tr class=ctor><td><code>new StarSprite(<br>&nbsp; bounds, nstars,<br>&nbsp; <em>[maxdepth]</em>)</code></td>
  <td>Creates a new sprite.</td></tr>
<tr class=inherited><td><code>.imgsrc</code></td>
  <td>A <code>ImageSource</code> for each star's content.</td></tr>
<tr><td><code>.bounds</code></td>
  <td>The bounds of all stars.</td></tr>
<tr><td><code>.velocity</code></td>
  <td>The velocity of the star movement.</td></tr>
<tr><td><code>.maxdepth</code></td>
  <td>The maximum depth of stars.</td></tr>
</table>

<a name="Projectile"><h3>Projectile : <a href="#Entity">Entity</a> (<code>entity.ts</code>)</h3></a>
<p>
A <code>Projectile</code> is an <code>Entity</code> that 
keeps moving towards a specific direction.
Suitable for bullets or obstacles.
<table border>
<tr class=ctor><td><code>new Projectile(pos)</code></td>
  <td>Creates a new projectile.</td></tr>
<tr class=inherited><td><code>.imgsrc</code></td>
  <td>A <code>ImageSource</code> for the entity's content.</td></tr>
<tr><td><code>.movement</code></td>
  <td>The velocity of the object.</td></tr>
<tr><td><code>.frame</code></td>
  <td>The rectangle where the object is kept alive within.</td></tr>
</table>

<a name="PhysicalEntity"><h3>PhysicalEntity : <a href="#Entity">Entity</a> (<code>entity.ts</code>)</h3></a>
<p>
An <code>Entity</code> that is affected by gravity.
Suitable for charcters or objects that can jump or fall.
<table border>
<tr class=ctor><td><code>new PhysicalEntity(pos)</code></td>
  <td>Creates a new entity.</td></tr>
<tr class=inherited><td><code>.alive</code></td>
  <td><code>true</code> if the entity is alive.</td></tr>
<tr class=inherited><td><code>.layer</code></td>
  <td>A <code>Layer</code> that the entity belongs to.</td></tr>
<tr class=inherited><td><code>.time</code></td>
  <td>The elapsed time since the entity started.</td></tr>
<tr class=inherited><td><code>.stopped</code></td>
  <td>A <code>Signal</code> that is signaled when the entity stops.</td></tr>
<tr class=inherited><td><code>.bounds</code></td>
  <td>A <code>Rect</code> for the entity's size and position.</td></tr>
<tr class=inherited><td><code>.imgsrc</code></td>
  <td>A <code>ImageSource</code> for the entity's content.</td></tr>
<tr class=inherited><td><code>.visible</code></td>
  <td><code>true</code> if the entity is visible.</td></tr>
<tr class=inherited><td><code>.zOrder</code></td>
  <td>The order that the entity is drawn to the screen.</td></tr>
<tr class=inherited><td><code>.scale</code></td>
  <td>A vector for the polarity of the entity image.</td></tr>
<tr><td><code>.physics</code></td>
  <td>The physics options.</td></tr>
<tr><td><code>.velocity</code></td>
  <td>A vector for the current velocity.</td></tr>
<tr class=inherited><td><code>.stop()</code></td>
  <td>Terminates the entity.</td></tr>
<tr class=inherited><td><code>.movePos(v)</code></td>
  <td>Moves the entity by <code>v</code>.</td></tr>
<tr class=inherited><td><code>.collider</code></td>
  <td>A <code>Rect</code>/<code>Circle</code> for the entity's collider.</td></tr>
<tr class=override><td><code>.update()</code></td>
  <td>Updates for the current frame.</td></tr>
<tr class=override><td><code>.render(ctx, bx, by)</code></td>
  <td>Draws the entity at the location (<code>bx</code>, <code>by</code>).</td></tr>
<tr class=override><td><code>.collidedWith(entity)</code></td>
  <td>Invoked when the entity collides another entity.</td></tr>
<tr class=inherited><td><code>.moveIfPossible(v, <em>[context]</em>)</code></td>
  <td>Moves the entity by <code>v</code> without colliding obstacles.</td></tr>
<tr class=inherited><td><code>.isMovable(v)</code></td>
  <td><code>true</code> if the entity is movable toward <code>v</code>.</td></tr>
<tr class=inherited><td><code>.getMove(v)</code></td>
  <td>Trims the vector <code>v</code> so that it doesn't collide.</td></tr>
<tr class=override><td><code>.getObstaclesFor(range, context)</code></td>
  <td>Returns a list of <code>Shape</code>s within <code>range</code>.</td></tr>
<tr class=override><td><code>.getFencesFor(range, context)</code></td>
  <td>Returns a list of bounding rectangles that limits the entity within.</td></tr>
<tr><td><code>.setJumpFunc(function)</code></td>
  <td>Sets the gravity function.</td></tr>
<tr><td><code>.setJump(jumpend)</code></td>
  <td>Starts a jump maneuver that ends at <code>t=jumpend</code>.</td></tr>
<tr class=override><td><code>.jump()</code></td>
  <td>Invoked when the entity starts jumping.</td></tr>
<tr><td><code>.fall()</code></td>
  <td>Invoked for every update.</td></tr>
<tr><td><code>.isLanded()</code></td>
  <td><code>true</code> if the entity is landed on a platform.</td></tr>
<tr class=override><td><code>.land()</code></td>
  <td>Invoked when the entity is landed on a platform.</td></tr>
<tr class=override><td><code>.isHolding()</code></td>
  <td><code>true</code> if the entity is in a state that stops falling.</td></tr>
</table>

<a name="PlatformerEntity"><h3>PlatformerEntity : <a href="#PhysicalEntity">PhysicalEntity</a> (<code>entity.ts</code>)</h3></a>
<p>
A <code>PhysicalEntity</code> that interacts with a <code>TileMap</code>.
Suitable for tile-based platformer games.
<table border>
<tr class=ctor><td><code>new PlatformerEntity(tilemap, pos)</code></td>
  <td>Creates a new entity.</td></tr>
<tr class=inherited><td><code>.alive</code></td>
  <td><code>true</code> if the entity is alive.</td></tr>
<tr class=inherited><td><code>.layer</code></td>
  <td>A <code>Layer</code> that the entity belongs to.</td></tr>
<tr class=inherited><td><code>.time</code></td>
  <td>The elapsed time since the entity started.</td></tr>
<tr class=inherited><td><code>.stopped</code></td>
  <td>A <code>Signal</code> that is signaled when the entity stops.</td></tr>
<tr class=inherited><td><code>.bounds</code></td>
  <td>A <code>Rect</code> for the entity's size and position.</td></tr>
<tr class=inherited><td><code>.imgsrc</code></td>
  <td>A <code>ImageSource</code> for the entity's content.</td></tr>
<tr class=inherited><td><code>.visible</code></td>
  <td><code>true</code> if the entity is visible.</td></tr>
<tr class=inherited><td><code>.zOrder</code></td>
  <td>The order that the entity is drawn to the screen.</td></tr>
<tr class=inherited><td><code>.scale</code></td>
  <td>A vector for the polarity of the entity image.</td></tr>
<tr class=inherited><td><code>.physics</code></td>
  <td>The physics options.</td></tr>
<tr class=inherited><td><code>.velocity</code></td>
  <td>A vector for the current velocity.</td></tr>
<tr><td><code>.tilemap</code></td>
  <td>A <code>TileMap</code> that interacts with the entity.</td></tr>
<tr class=inherited><td><code>.stop()</code></td>
  <td>Terminates the entity.</td></tr>
<tr class=inherited><td><code>.movePos(v)</code></td>
  <td>Moves the entity by <code>v</code>.</td></tr>
<tr class=inherited><td><code>.collider</code></td>
  <td>A <code>Rect</code>/<code>Circle</code> for the entity's collider.</td></tr>
<tr class=override><td><code>.update()</code></td>
  <td>Updates for the current frame.</td></tr>
<tr class=override><td><code>.render(ctx, bx, by)</code></td>
  <td>Draws the entity at the location (<code>bx</code>, <code>by</code>).</td></tr>
<tr class=override><td><code>.collidedWith(entity)</code></td>
  <td>Invoked when the entity collides another entity.</td></tr>
<tr class=inherited><td><code>.moveIfPossible(v, <em>[context]</em>)</code></td>
  <td>Moves the entity by <code>v</code> without colliding obstacles.</td></tr>
<tr class=inherited><td><code>.isMovable(v)</code></td>
  <td><code>true</code> if the entity is movable toward <code>v</code>.</td></tr>
<tr class=inherited><td><code>.getMove(v)</code></td>
  <td>Trims the vector <code>v</code> so that it doesn't collide.</td></tr>
<tr class=override><td><code>.getFencesFor(range, context)</code></td>
  <td>Returns a list of bounding rectangles that limits the entity within.</td></tr>
<tr class=inherited><td><code>.setJumpFunc(function)</code></td>
  <td>Sets the gravity function.</td></tr>
<tr class=inherited><td><code>.setJump(jumpend)</code></td>
  <td>Starts a jump maneuver that ends at <code>t=jumpend</code>.</td></tr>
<tr class=override><td><code>.jump()</code></td>
  <td>Invoked when the entity starts jumping.</td></tr>
<tr class=inherited><td><code>.fall()</code></td>
  <td>Invoked for every update.</td></tr>
<tr class=inherited><td><code>.isLanded()</code></td>
  <td><code>true</code> if the entity is landed on a platform.</td></tr>
<tr class=override><td><code>.land()</code></td>
  <td>Invoked when the entity is landed on a platform.</td></tr>
</table>

<a name="ScrollLayer"><h3>ScrollLayer : <a href="#Layer">Layer</a> (<code>layer.ts</code>)</h3></a>
<p>
A <code>Layer</code> that can scroll the displayed area. 
Only shows the objects within the window.
<table border>
<tr class=ctor><td><code>new ScrollLayer(window)</code></td>
  <td>Creates a new layer.</td></tr>
<tr class=inherited><td><code>.tasks</code></td>
  <td>A list of <code>Task</code>s that belong to the layer.</td></tr>
<tr class=inherited><td><code>.sprites</code></td>
  <td>A list of <code>Sprite</code>s that belong to the layer.</td></tr>
<tr class=inherited><td><code>.entities</code></td>
  <td>A list of <code>Entity</code>s that belong to the layer.</td></tr>
<tr><td><code>.window</code></td>
  <td>A <code>Rect</code> that specifies the window.</td></tr>
<tr class=override><td><code>.init()</code></td>
  <td>Invoked when the layer is initialized.</td></tr>
<tr class=override><td><code>.tick(t)</code></td>
  <td>Invoked for every frame.</td></tr>
<tr class=inherited><td><code>.render(ctx, bx, by)</code></td>
  <td>Draws all the sprites at the location (<code>bx</code>, <code>by</code>).</td></tr>
<tr class=inherited><td><code>.moveAll(v)</code></td>
  <td>Moves all the sprites by <code>v</code>.</td></tr>
<tr><td><code>.moveCenter(v)</code></td>
  <td>Moves the window by <code>v</code>.</td></tr>
<tr><td><code>.setCenter(bounds, rect)</code></td>
  <td>Centers the window around <code>rect</code>.</td></tr>
<tr class=inherited><td><code>.addTask(task)</code></td>
  <td>Adds a <code>Task</code>/<code>Sprite</code>/<code>Entity</code> to the list.</td></tr>
<tr class=inherited><td><code>.findEntities(rect, <em>[entities, [f]]</em>)</code></td>
  <td>Returns a list of entities that overlap <code>rect</code>.</td></tr>
</table>

<a name="GameScene"><h3>GameScene : <a href="#Scene">Scene</a> (<code>scene.ts</code>)</h3></a>
<p>
A <code>Scene</code> that has one <code>Layer</code> with
a few convenient methods.
<table border>
<tr class=ctor><td><code>new GameScene(app)</code></td>
  <td>Creates a new scene.</td></tr>
<tr class=inherited><td><code>.app</code></td>
  <td>The <code>App</code> object that the scene belongs to.</td></tr>
<tr class=inherited><td><code>.screen</code></td>
  <td>The canvas rectangle.</td></tr>
<tr><td><code>.layer</code></td>
  <td>A <code>Layer</code> for this scene.</td></tr>
<tr><td><code>.entities</code></td>
  <td>An alias to <code>layer.entities</code>.</td></tr>
<tr><td><code>.addTask(task)</code></td>
  <td>Adds a <code>Task</code>/<code>Sprite</code>/<code>Entity</code> to the list.</td></tr>
<tr class=inherited><td><code>.changeScene(scene)</code></td>
  <td>Signals the <code>App</code> to switch to a scene.</td></tr>
<tr class=override><td><code>.init()</code></td>
  <td>Initializes the scene.</td></tr>
<tr class=override><td><code>.tick(t)</code></td>
  <td>Invoked for every frame.</td></tr>
<tr class=override><td><code>.render(ctx, bx, by)</code></td>
  <td>Draws the scene at the location (<code>bx</code>, <code>by</code>).</td></tr>
<tr class=override><td><code>.setDir(v)</code></td>
  <td>Invoked when a directional input is changed.</td></tr>
<tr class=override><td><code>.setAction(action)</code></td>
  <td>Invoked when the action key state is changed.</td></tr>
<tr class=override><td><code>.setCancel(cancel)</code></td>
  <td>Invoked when the cancel key state is changed.</td></tr>
<tr class=override><td><code>.keydown(keyCode)</code></td>
  <td>Invoked when a key is pressed.</td></tr>
<tr class=override><td><code>.keyup(keyCode)</code></td>
  <td>Invoked when a key is released.</td></tr>
<tr class=override><td><code>.mousedown(x, y, button)</code></td>
  <td>Invoked when a mouse button is pressed.</td></tr>
<tr class=override><td><code>.mouseup(x, y, button)</code></td>
  <td>Invoked when a mouse button is released.</td></tr>
<tr class=override><td><code>.mousemove(x, y)</code></td>
  <td>Invoked when a mouse pointer is moved.</td></tr>
</table>

<a name="HTMLScene"><h3>HTMLScene : <a href="#Scene">Scene</a> (<code>scene.ts</code>)</h3></a>
<p>
A <code>Scene</code> for a static HTML text. 
Suitable for game title or help screen, etc.
<table border>
<tr class=ctor><td><code>new HTMLScene(app, text)</code></td>
  <td>Creates a new HTML scene.</td></tr>
<tr><td><code>.text</code></td>
  <td>A string to display.</td></tr>
<tr class=inherited><td><code>.changeScene(scene)</code></td>
  <td>Signals the <code>App</code> to switch to a scene.</td></tr>
<tr class=override><td><code>.change()</code></td>
  <td>Invoked when there's a mouse or keyboard input.</td></tr>
</table>

<a name="text"><h2>Text Library</h2></a>
<a name="Font"><h3>Font (<code>text.ts</code>)</h3></a>
<p>
A <code>Font</code> represents a monospace bitmap font.
<table border>
<tr class=ctor><td><code>new Font(glyphs, <em>[color, [scale]]</em>)</code></td>
  <td>Creates a <code>Font</code> with a given <code>glyphs</code>.</td></tr>
<tr><td><code>.width</code></td>
  <td>The width of individual character.</td></tr>
<tr><td><code>.height</code></td>
  <td>The height of individual character.</td></tr>
<tr><td><code>.getSize(text)</code></td>
  <td>Computes the pixel size for a given text.</td></tr>
<tr><td><code>.renderString(ctx, text, x, y)</code></td>
  <td>Draws the text at a given location.</td></tr>
</table>

<a name="ShadowFont"><h3>ShadowFont : <a href="#Font">Font</a> (<code>text.ts</code>)</h3></a>
<p>
A <code>Font</code> with shadow.
<table border>
<tr class=ctor><td><code>new ShadowFont(glyphs,<br>&nbsp; <em>[color, [scale,<br>&nbsp; [shadowcolor,<br>&nbsp; [shadowdist]]]]</em>)</code></td>
  <td>Creates a <code>ShadowFont</code> with a given <code>glyphs</code>.</td></tr>
<tr class=inherited><td><code>.width</code></td>
  <td>The width of individual character.</td></tr>
<tr class=inherited><td><code>.height</code></td>
  <td>The height of individual character.</td></tr>
<tr class=inherited><td><code>.getSize(text)</code></td>
  <td>Computes the pixel size for a given text.</td></tr>
<tr class=inherited><td><code>.renderString(ctx, text, x, y)</code></td>
  <td>Draws the text at a given location.</td></tr>
<tr><td><code>.getSize2(text)</code></td>
  <td>Computes the pixel size for a given text (including the shadow).</td></tr>
</table>

<a name="TextBox"><h3>TextBox : <a href="#Sprite">Sprite</a> (<code>text.ts</code>)</h3></a>
<a name="DialogBox"><h3>DialogBox : <a href="#TextBox">TextBox</a> (<code>text.ts</code>)</h3></a>

<a name="animation"><h2>Animation Library</h2></a>

<a name="Animator"><h3>Animator (<code>animation.ts</code>)</h3></a>
<a name="Tweener"><h3>Tweener : <a href="#Animator">Animator</a> (<code>animation.ts</code>)</h3></a>
<a name="PolyTweener"><h3>PolyTweener : <a href="#Tweener">Tweener</a> (<code>animation.ts</code>)</h3></a>
<a name="PolyTweenerIn"><h3>PolyTweenerIn : <a href="#PolyTweener">PolyTweener</a> (<code>animation.ts</code>)</h3></a>
<a name="PolyTweenerOut"><h3>PolyTweenerOut : <a href="#PolyTweener">PolyTweener</a> (<code>animation.ts</code>)</h3></a>
<a name="PolyTweenerInOut"><h3>PolyTweenerInOut : <a href="#PolyTweener">PolyTweener</a> (<code>animation.ts</code>)</h3></a>
<a name="Blinker"><h3>Blinker : <a href="#Widget">Widget</a> (<code>animation.ts</code>)</h3></a>

<a name="pathfinding"><h2>Pathfinding Library</h2></a>

<a name="PlanActor"><h3>PlanActor (<code>planmap.ts</code>)</h3></a>
<a name="PlanAction"><h3>PlanAction (<code>planmap.ts</code>)</h3></a>
<a name="PlanProfile"><h3>PlanProfile (<code>planmap.ts</code>)</h3></a>
<a name="PlanMap"><h3>PlanMap (<code>planmap.ts</code>)</h3></a>
<a name="PlanActionRunner"><h3>PlanActionRunner (<code>planrunner.ts</code>)</h3></a>
<a name="PlanningEntity"><h3>PlanningEntity (<code>planrunner.ts</code>)</h3></a>

</div>
</div> <!-- main -->
